# Why TypeScript Over JavaScript?

**JavaScript Limitation:**
JS is **dynamically typed**. This means types are not checked at compile-time, only at runtime.

**Problems this causes:**

* Hard to catch errors in large projects
* Bugs appear late during runtime
* Code readability and maintainability are harder

**TypeScript Advantage:**

* **Static typing** → errors are caught at compile-time
* Better **autocompletion and IDE support**
* Makes large-scale projects more **robust and maintainable**
* Supports **interfaces, enums, generics, modules**

---

# Example Problem

**Problem:**
Create a function `addNumbers` that takes two numbers, adds them, and returns the result. Then use it to calculate totals in an array of objects representing products.

In **JavaScript**, you might write:

```js
// products.js
const products = [
    { name: "Laptop", price: 1000 },
    { name: "Mouse", price: 50 },
    { name: "Keyboard", price: 80 },
];

function addNumbers(a, b) {
    return a + b;
}

// Calculate total price
let total = 0;
for (let product of products) {
    total = addNumbers(total, product.price);
}

console.log("Total Price:", total);
```

**What can go wrong?**

* Accidentally pass a string instead of number:

```js
total = addNumbers(total, "50"); // No error in JS! Returns "050"
```

* Large projects → hard to track types → runtime bugs

---

# TypeScript Solution

**Step 1: Define types**

* We define the **structure** of our product and enforce **number types** for prices.

```ts
// products.ts
interface Product {
    name: string;
    price: number;
}

const products: Product[] = [
    { name: "Laptop", price: 1000 },
    { name: "Mouse", price: 50 },
    { name: "Keyboard", price: 80 },
];

// Type-safe addNumbers function
function addNumbers(a: number, b: number): number {
    return a + b;
}

// Calculate total price
let total: number = 0;
for (let product of products) {
    total = addNumbers(total, product.price);
}

console.log("Total Price:", total);
```

**Dry Run:**

1. `total = 0`
2. First iteration → `total = addNumbers(0, 1000) = 1000`
3. Second iteration → `total = addNumbers(1000, 50) = 1050`
4. Third iteration → `total = addNumbers(1050, 80) = 1130`

**Output:**

```
Total Price: 1130
```

---

# Key Benefits Illustrated

1. **Compile-time type checking**

```ts
total = addNumbers(total, "50"); // ❌ Error in TS: Argument of type 'string' is not assignable to parameter of type 'number'.
```

* JS would silently concatenate `"0" + "50"` → wrong result
* TS prevents this **before running the code**

2. **Clear contracts**

* `interface Product` defines exactly what each product must have
* Function signature `addNumbers(a: number, b: number): number` ensures correct usage

3. **Better IDE support**

* Autocompletion for `product.name` and `product.price`
* Early warnings if you misname a property or pass wrong types

4. **Scalability**

* If the project grows to 1000+ files, TS keeps your code **robust and maintainable**

---

# Optional: Using JSX/TSX

If this were a **React project** (`.tsx` file), we can also enforce types for components:

```tsx
// ProductList.tsx
import React from "react";

interface Product {
    name: string;
    price: number;
}

interface Props {
    products: Product[];
}

const ProductList: React.FC<Props> = ({ products }) => {
    return (
        <div>
            <h2>Products</h2>
            <ul>
                {products.map((product, index) => (
                    <li key={index}>
                        {product.name}: ${product.price}
                    </li>
                ))}
            </ul>
        </div>
    );
};

export default ProductList;
```

**Advantages in React/TSX:**

* Component props are **type-checked**
* Helps prevent passing wrong props → reduces bugs in UI
* IDE gives autocompletion for `products.map(...)`

---

# Summary: Why TypeScript Wins Here

| Feature        | JavaScript            | TypeScript                    |
| -------------- | --------------------- | ----------------------------- |
| Type Checking  | None (runtime errors) | Compile-time                  |
| IDE Support    | Limited               | Autocompletion, hints, errors |
| Interfaces     | Not available         | Available                     |
| Large Projects | Hard to maintain      | Easier and robust             |
| Bug Prevention | Late detection        | Early detection               |

**Verdict:**

* JavaScript works for small scripts
* TypeScript becomes **essential for scalable, safe, and maintainable code**

---