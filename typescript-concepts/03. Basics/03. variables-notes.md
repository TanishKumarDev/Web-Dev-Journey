
# TypeScript Variables

In TypeScript, **variables** are used to store data that can be referenced and manipulated throughout your program. TypeScript enhances JavaScript by allowing **static type annotations**, which help catch errors at compile-time instead of runtime.

---

## Types of Variable Declarations

TypeScript provides three ways to declare variables: `let`, `const`, and `var`. Each has different behavior regarding **scope** and **reassignments**.

### 1. Declare Type and Value Together

```ts
let name: string = 'Amit';
const age: number = 25;
```

* `name` is a string variable.
* `age` is a constant number.
* The type is explicitly defined along with the value.

### 2. Declare Type Without Value

```ts
let city: string;
console.log(city); // undefined
```

* Type is defined, value is not. Default value is `undefined`.

### 3. Declare Value Without Type

```ts
let country = 'India';
console.log(country); // India
```

* Type is **inferred** by TypeScript (here `string`).

---

## Variable Declaration Keywords

### 1. var

* **Function-scoped**
* Can lead to unexpected behavior due to **hoisting**.

```ts
function testVar() {
  var globalVar = "I am a function-scoped variable";
  console.log(globalVar);
}
testVar();
```

**Output:**

```
I am a function-scoped variable
```

* `globalVar` is not accessible outside the function.
* Avoid `var` in modern TypeScript due to unpredictability.

---

### 2. let

* **Block-scoped**
* Prevents redeclaration within the same scope.

```ts
let count = 5;
if (count > 0) {
  let message = "Count is positive";
  console.log(message); // Count is positive
}
// console.log(message); // Error: message is not accessible here
```

---

### 3. const

* Block-scoped
* Cannot be reassigned after initialization.

```ts
const country = "India";
// country = "USA"; // Error: Cannot assign to 'country'
console.log(country); // India
```

**Rules for variable names:**

* Can contain letters (uppercase/lowercase), digits (not as the first character), `_`, and `$`.
* Cannot contain other special characters.

---

## Type Annotations

Type annotations improve **clarity, maintainability**, and **catch errors** at compile-time.

```ts
let userName: string = "Arjun";  
let age: number = 25;            
let isActive: boolean = true;    

function greetUser(name: string, age: number): string {
  return `Hello, ${name}! You are ${age} years old.`;
}

let greeting = greetUser(userName, age);
console.log(greeting);
```

**Output:**

```
Hello, Arjun! You are 25 years old.
```

* `userName` must hold a string.
* `age` must hold a number.
* `isActive` must hold a boolean.
* Function parameters and return type are strictly typed.

---

## Variable Scopes

Understanding scope is crucial for managing variable accessibility.

### 1. Local Scope

```ts
function testLocalScope() {
  let localVar = "I am local";
  console.log(localVar);  
}
// console.log(localVar); // Error: localVar is not defined
```

* `localVar` exists only inside the function.

### 2. Global Scope

```ts
let globalVar = 10;  
function displayGlobalVar() {
  console.log(globalVar); 
}
displayGlobalVar();
```

**Output:**

```
10
```

* `globalVar` is accessible throughout the program.

### 3. Class Scope

```ts
class Employee {
    salary: number = 50000;
    printSalary(): void {
        console.log(`Salary: ${this.salary}`);
    }
}

const emp = new Employee();
emp.printSalary();
```

**Output:**

```
50000
```

* Class-level variables are accessible to all class methods.

---

### Combined Example

```ts
let globalVar: number = 10;

class Geeks {
    private classVar: number = 11;

    assignNum(): void {
        let localVar: number = 12;
        console.log('Local Variable: ' + localVar);
    }
}

console.log('Global Variable: ' + globalVar);

let obj = new Geeks();
obj.assignNum();
```

**Output:**

```
Global Variable: 10
Local Variable: 12
```

* `globalVar` → global scope
* `classVar` → class scope, private to `Geeks`
* `localVar` → local to `assignNum` method

---
