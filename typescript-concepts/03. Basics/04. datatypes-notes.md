
# TypeScript Data Types

In TypeScript, **data types** define the kind of values a variable can hold. Using data types ensures **type safety** and improves code readability, maintainability, and error detection at compile time.

---

## Primitive Types

These are basic, immutable values directly assigned to variables.

| Type      | Keyword     | Description                                                     |
| --------- | ----------- | --------------------------------------------------------------- |
| Number    | `number`    | Represents integers and floating-point numbers.                 |
| String    | `string`    | Represents textual data.                                        |
| Boolean   | `boolean`   | Represents logical values: `true` or `false`.                   |
| Null      | `null`      | Represents the intentional absence of any value.                |
| Undefined | `undefined` | Represents uninitialized variables.                             |
| Symbol    | `symbol`    | Represents unique, immutable values, often used as object keys. |
| BigInt    | `bigint`    | Represents integers with arbitrary precision.                   |

### Example:

```ts
let age: number = 25;
let name: string = "Tanish";
let isActive: boolean = true;
let uid: symbol = Symbol("id");
let bigNum: bigint = 9007199254740991n;
```

---

## Object Types

Object types are **complex structures** that can contain multiple values and functions. They are mutable and can be manipulated after creation.

| Type      | Description                                                     |
| --------- | --------------------------------------------------------------- |
| Object    | Any non-primitive type (use specific types instead).            |
| Array     | Collection of elements of a specific type.                      |
| Tuple     | Array with a fixed number of elements of specific types.        |
| Enum      | Named constants for a set of related values.                    |
| Function  | Callable entity with parameter and return type definitions.     |
| Class     | Blueprint for creating objects with properties and methods.     |
| Interface | Describes the shape of an object with property names and types. |

### Examples:

```ts
// Array
let numbers: number[] = [1, 2, 3];

// Tuple
let person: [string, number] = ["Alice", 30];

// Enum
enum Direction { Up, Down, Left, Right }
let dir: Direction = Direction.Up;

// Interface
interface User {
  name: string;
  age: number;
}
let user: User = { name: "Tanish", age: 25 };

// Function
function add(a: number, b: number): number {
  return a + b;
}

// Class
class Employee {
  id: number;
  constructor(id: number) {
    this.id = id;
  }
}
let emp = new Employee(101);
```

---

## Advanced Types

TypeScript allows **more complex type definitions** for scalable applications.

| Type               | Description                                |
| ------------------ | ------------------------------------------ |
| Union Types        | Variable can hold multiple types.          |
| Intersection Types | Combines multiple types, must satisfy all. |
| Literal Types      | Assign exact values only.                  |
| Mapped Types       | Transform properties of an existing type.  |

### Example:

```ts
// Union
let pid: number | string;
pid = 101;
pid = "202A";

// Intersection
interface A { name: string; }
interface B { age: number; }
type C = A & B;
let obj: C = { name: "Alice", age: 25 };

// Literal
let direction: "Up" | "Down";
direction = "Up"; // valid
// direction = "Left"; // Error
```

---

## Best Practices

1. **Use `let` and `const`** instead of `var` for block scope.
2. **Avoid `any` type**; it bypasses type checking.
3. **Leverage Type Inference** when possible.
4. **Use Utility Types** like `Partial<T>`, `Readonly<T>` for cleaner type definitions.

---