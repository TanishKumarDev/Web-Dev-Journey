# Union Type to Intersection Type in TypeScript

## Overview

In TypeScript, **Union Types (`|`)** and **Intersection Types (`&`)** are powerful tools for combining types — but they behave very differently.
Sometimes, you may need to **transform a union type into an intersection type**, especially in advanced type manipulation and utility type creation.

---

## Union Type

A **union type** allows a variable to hold **one of several possible types**.

```ts
type Animal = "Dog" | "Cat" | "Bird";

let pet: Animal;
pet = "Dog";   // ✅ valid
pet = "Lion";  // ❌ Error
```

Here, `Animal` can be either `"Dog"`, `"Cat"`, or `"Bird"` — **only one at a time**.

---

## Intersection Type

An **intersection type** combines **multiple types into one**, meaning the variable must satisfy **all** of them.

```ts
type Person = { name: string } & { age: number };

const user: Person = {
  name: "Tanish",
  age: 22
}; // ✅ valid
```

Here, `Person` has **both** `name` and `age` — not one or the other.

---

## Goal

We want to **convert a union type** (e.g., `{a} | {b} | {c}`) into an **intersection type** (`{a} & {b} & {c}`).

---

## Approach 1 — Using Distributive Conditional Types

### Concept

TypeScript’s **conditional types** can distribute over a union, allowing us to map and infer an intersection.

### Implementation

```ts
type UnionToIntersection<U> = (
  U extends any ? (k: U) => void : never
) extends (k: infer I) => void
  ? I
  : never;

// Example usage
type UnionType = { a: number } | { b: string } | { c: boolean };
type IntersectionType = UnionToIntersection<UnionType>;

const myObject: IntersectionType = {
  a: 42,
  b: "hello",
  c: true
};

console.log(myObject);
```

### Output

```json
{
  "a": 42,
  "b": "hello",
  "c": true
}
```

### Explanation

1. `U extends any ? ... : ...` makes the type **distributive**, so each union member is processed individually.
2. `(k: U) => void` creates a function type.
3. The second function `(k: infer I)` **infers `I`** as the **intersection** of all `U`.

Hence, `{ a } | { b } | { c }` becomes `{ a } & { b } & { c }`.

---

## Approach 2 — Using Conditional Template Literal Types

### Concept

Conditional **template literal types** can recursively build intersections by combining members of a union type.

### Implementation

```ts
type UnionToIntersection<U> = (
  U extends any ? (k: U) => void : never
) extends (k: infer I) => void
  ? I
  : never;

// Example usage
type UnionType = { a: number } | { b: string } | { c: boolean };
type IntersectionType = UnionToIntersection<UnionType>;

const myObject: IntersectionType = {
  a: 22,
  b: "GFG",
  c: true
};

console.log(myObject);
```

### Output

```json
{
  "a": 22,
  "b": "GFG",
  "c": true
}
```

### Explanation

Even though this looks identical to the first approach, template literal types allow **string manipulation** and advanced transformations (like key renaming or property formatting) in real-world use cases.

---

## Key Difference Between Union and Intersection

| Concept               | Syntax                | Meaning                            | Example                          |
| --------------------- | --------------------- | ---------------------------------- | -------------------------------- |
| **Union Type**        | `A \| B`              | One of several types               | `"Dog" \| "Cat"`                 |
| **Intersection Type** | `A & B`               | Must satisfy all types             | `{name: string} & {age: number}` |
| **Conversion**        | `UnionToIntersection` | Combine all union members into one | `{a} \| {b}` → `{a, b}`          |

---

## Practical Example — Combining Props in React (TSX Example)

```tsx
type CommonProps = { id: number };
type ButtonProps = { onClick: () => void };
type InputProps = { placeholder: string };

type Combined = UnionToIntersection<ButtonProps | InputProps | CommonProps>;

const componentProps: Combined = {
  id: 1,
  onClick: () => console.log("Clicked"),
  placeholder: "Enter text"
};

function UIComponent(props: Combined) {
  return (
    <div>
      <input id={props.id.toString()} placeholder={props.placeholder} />
      <button onClick={props.onClick}>Click</button>
    </div>
  );
}
```

### Explanation

Using intersection transformation helps combine multiple component props cleanly — powerful in **React TypeScript** patterns for shared prop definitions.

---

## Summary

| Aspect     | Union                    | Intersection                            |     |
| ---------- | ------------------------ | --------------------------------------- | --- |
| Operator   | `                        | `                                       | `&` |
| Meaning    | Either type              | All types together                      |     |
| Example    | `"Cat" \| "Dog"`         | `{a: number} & {b: string}`             |     |
| Conversion | `UnionToIntersection<T>` | Converts `T` from union to intersection |     |
| Use Case   | Flexibility              | Strict composition                      |     |

---

## Takeaway

* **Union types** = *“either or”*
* **Intersection types** = *“both (or all)”*
* You can use **distributive conditional types** to transform one into the other.
* Very useful in **advanced type utilities**, **React prop merging**, and **type-safe APIs**.
