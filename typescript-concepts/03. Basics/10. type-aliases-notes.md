# Type Aliases in TypeScript

## Overview

In TypeScript, **Type Aliases** allow you to create a **custom name for an existing type**.
They improve code readability, reusability, and make complex types easier to reference.

A **type alias doesn’t create a new type**, it just provides a **new name (alias)** for a type that already exists.

---

## Why Use Type Aliases?

| Problem                                        | Solution                     |
| ---------------------------------------------- | ---------------------------- |
| Repeating the same complex type multiple times | Define a reusable alias      |
| Hard-to-read union or intersection types       | Use a descriptive alias      |
| Need to group related types                    | Aliases improve organization |

---

## Syntax

```ts
type AliasName = existingType;
```

Example:

```ts
type ID = number | string;
```

Now, instead of writing `number | string` everywhere, you can simply use `ID`.

---

## Example 1 — Basic Type Alias

```ts
// Define alias for multiple primitive types
type TypeAlias = number | string | boolean;

// Variable can hold only allowed types
let variable: TypeAlias;

variable = 1; // ✅
console.log(variable);

variable = "geeksforgeeks"; // ✅
console.log(variable);

variable = true; // ✅
console.log(variable);

variable = () => {}; // ❌ Error
```

### Output

```
1
geeksforgeeks
true
```

### Explanation

The alias `TypeAlias` allows only **number**, **string**, and **boolean**.
Assigning a function causes a **TypeScript compile-time error**, improving safety.

---

## Example 2 — Type Alias in Functions

```ts
// Define alias for allowed ID types
type AnotherType = number | string;

function displayId(id: AnotherType) {
  return "My ID is: " + id.toString();
}

console.log(displayId("AF565")); // ✅
console.log(displayId(565));     // ✅
console.log(displayId(true));    // ❌ Error
```

### Output

```
My ID is: AF565
My ID is: 565
```

### Explanation

* The alias `AnotherType` allows both **number** and **string**.
* Passing any other type raises a **compile-time error** before execution.

---

## Example 3 — String Literals as Type Aliases

```ts
// Define alias for specific string values
type ResponseType = "yes" | "no";

let answer: ResponseType;

answer = "yes";    // ✅ Valid
answer = "maybe";  // ❌ Error
```

### Output

```bash
error TS2322: Type '"maybe"' is not assignable to type 'ResponseType'.
```

### Explanation

This ensures the variable can only hold `"yes"` or `"no"`,
preventing invalid strings at **compile time**.

---

## Example 4 — Object Type Alias

```ts
// Define alias for an object type
type User = {
  id: number;
  name: string;
  isActive: boolean;
};

const user1: User = {
  id: 101,
  name: "Tanish",
  isActive: true,
};
```

This makes it easy to reuse the same object structure across your project.

---

## Example 5 — Type Alias with Intersection

```ts
type Base = { id: number };
type Details = { name: string; age: number };

type UserProfile = Base & Details;

const user: UserProfile = {
  id: 1,
  name: "Tanish",
  age: 22
};
```

Here, the alias `UserProfile` combines both types into one via `&`.

---

## Example 6 — React (TSX) Use Case

Type aliases are often used to define **component props** for better clarity and reuse.

```tsx
type ButtonProps = {
  label: string;
  onClick: () => void;
  variant?: "primary" | "secondary";
};

const Button = ({ label, onClick, variant = "primary" }: ButtonProps) => {
  return (
    <button
      onClick={onClick}
      style={{
        backgroundColor: variant === "primary" ? "#007bff" : "#6c757d",
        color: "#fff",
        padding: "10px 20px",
        borderRadius: "8px",
        border: "none",
      }}
    >
      {label}
    </button>
  );
};

export default Button;
```

### Explanation

* `ButtonProps` defines all prop types in a single alias.
* The alias improves readability and catches wrong prop types at compile time.

---

## Difference Between `type` and `interface`

| Feature                                            | `type`                 | `interface`                       |
| -------------------------------------------------- | ---------------------- | --------------------------------- |
| Can alias any type (primitive, union, tuple, etc.) | ✅                      | ❌ Only object types               |
| Supports union & intersection                      | ✅                      | Partial (via extends)             |
| Extendable                                         | Limited (via `&`)      | Fully extendable (via `extends`)  |
| Declaration merging                                | ❌                      | ✅                                 |
| Recommended for                                    | Complex or mixed types | Object shapes and class contracts |

---

## Summary

| Concept        | Description                                        |
| -------------- | -------------------------------------------------- |
| **Definition** | Type alias gives a custom name to an existing type |
| **Usage**      | Improves code clarity and reusability              |
| **Supports**   | Primitives, objects, unions, intersections         |
| **Common in**  | React Props, API responses, utility types          |

---

## Takeaway

* Use **type aliases** to simplify and reuse complex types.
* They don’t create new types but make your code more **readable and maintainable**.
* Use `type` for **unions/intersections**, `interface` for **object contracts**.

---