# 1. The Root Problem

React’s default data flow is **unidirectional**:

* Parent → Child via props.

This is fine for small components, but as your app grows, it creates **prop drilling** — data passed down through many unnecessary levels.

Example:

```jsx
<App user="Tanish" />
  ↓
<Header user="Tanish" />
  ↓
<Navbar user="Tanish" />
  ↓
<Profile user="Tanish" />
```

Every middle component has to pass props **just to reach** the one that actually needs it.

This becomes **unmaintainable** as your app scales.

Hence, React provides **Context API**.
And Redux was built **before Context became strong**, to solve **state management complexity**.

---

# 2. Context API

## What It Is

A **built-in React feature** for sharing data globally without prop drilling.
It’s ideal for **lightweight global state** like theme, auth, or language.

---

## The Core Concepts

1. `createContext()` → Create the context
2. `Provider` → Supplies the data to components
3. `useContext()` → Reads the data anywhere in the tree

---

## Example Problem

You want to share user login info (`name`, `email`) across components — header, sidebar, dashboard, etc.

---

## Step 1: Create the Context

`src/context/UserContext.js`

```jsx
import { createContext } from 'react';
const UserContext = createContext();
export default UserContext;
```

---

## Step 2: Provide Context Value

`src/App.jsx`

```jsx
import React from 'react';
import UserContext from './context/UserContext';
import Dashboard from './Dashboard';

const App = () => {
  const user = { name: 'Tanish', email: 'tanish@example.com' };

  return (
    <UserContext.Provider value={user}>
      <Dashboard />
    </UserContext.Provider>
  );
};

export default App;
```

---

## Step 3: Consume Context Anywhere

`src/Dashboard.jsx`

```jsx
import React, { useContext } from 'react';
import UserContext from './context/UserContext';

const Dashboard = () => {
  const user = useContext(UserContext);
  return <h2>Welcome, {user.name}</h2>;
};

export default Dashboard;
```

---

## Flow Explanation

1. `createContext()` → creates the global data container
2. `Provider` → wraps components and gives them the value
3. `useContext()` → pulls the value directly, no prop drilling

---

## Problem Solved

* Removes unnecessary prop passing
* Keeps shared state accessible globally

---

## Limitations

* Re-renders every component that consumes context when value changes
* Not great for *complex, frequently updated global states* (like cart items, filters, counters)
* No built-in way to manage side effects or async logic cleanly

That’s where **Redux** comes in.

---

# 3. Redux

## What It Is

Redux is a **predictable state container** for JavaScript apps.
It helps manage **complex global states** and debugging large applications.

---

## Core Concepts

| Term                          | Meaning                                      |
| ----------------------------- | -------------------------------------------- |
| **Store**                     | The single global state of the app           |
| **Action**                    | Describes what happened                      |
| **Reducer**                   | Pure function that decides how state changes |
| **Dispatch**                  | Sends action to reducer                      |
| **useSelector / useDispatch** | React hooks to connect to store              |

---

## The Idea Behind Redux

Instead of passing state down manually or using multiple contexts,
you maintain a **single global store** that holds all app data.

All changes go through **actions + reducers**, ensuring consistency and predictability.

---

## Example Problem

You want to manage a **counter** globally.

---

## Step 1: Install Redux Toolkit

```bash
npm install @reduxjs/toolkit react-redux
```

Redux Toolkit (RTK) simplifies setup compared to old Redux.

---

## Step 2: Create the Store

`src/store/store.js`

```jsx
import { configureStore } from '@reduxjs/toolkit';
import counterReducer from './counterSlice';

const store = configureStore({
  reducer: {
    counter: counterReducer,
  },
});

export default store;
```

---

## Step 3: Create a Slice (Reducer + Actions)

`src/store/counterSlice.js`

```jsx
import { createSlice } from '@reduxjs/toolkit';

const counterSlice = createSlice({
  name: 'counter',
  initialState: { value: 0 },
  reducers: {
    increment: (state) => { state.value += 1; },
    decrement: (state) => { state.value -= 1; },
    reset: (state) => { state.value = 0; },
  },
});

export const { increment, decrement, reset } = counterSlice.actions;
export default counterSlice.reducer;
```

---

## Step 4: Provide Store Globally

`src/main.jsx`

```jsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import { Provider } from 'react-redux';
import store from './store/store';

ReactDOM.createRoot(document.getElementById('root')).render(
  <Provider store={store}>
    <App />
  </Provider>
);
```

---

## Step 5: Use Redux in a Component

`src/App.jsx`

```jsx
import React from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { increment, decrement, reset } from './store/counterSlice';

const App = () => {
  const count = useSelector((state) => state.counter.value);
  const dispatch = useDispatch();

  return (
    <div>
      <h2>Count: {count}</h2>
      <button onClick={() => dispatch(increment())}>+</button>
      <button onClick={() => dispatch(decrement())}>-</button>
      <button onClick={() => dispatch(reset())}>Reset</button>
    </div>
  );
};

export default App;
```

---

## Flow Explanation

1. **Store** holds all global state
2. **Slice** defines how state changes (reducers)
3. **Dispatch(action)** → triggers reducer update
4. **useSelector()** → reads updated state

---

## Problems Solved by Redux

* Complex state management
* Predictable state transitions
* Easy debugging with Redux DevTools
* Scalable for large apps

---

# 4. Context vs Redux — When to Use Which

| Feature       | Context API                       | Redux                                            |
| ------------- | --------------------------------- | ------------------------------------------------ |
| Built-in      | Yes                               | No (needs install)                               |
| Complexity    | Simple                            | High (but predictable)                           |
| State updates | Causes re-renders                 | Optimized through selectors                      |
| Async logic   | Manual setup                      | Built-in with Redux Toolkit                      |
| Best for      | Light global states (theme, auth) | Large-scale apps (cart, dashboard, admin panels) |

---

# 5. Problem-Solving Mindset Summary

| Situation                               | Thought Process                        |
| --------------------------------------- | -------------------------------------- |
| Need to share light data globally       | Use Context                            |
| Need multiple unrelated global states   | Use multiple contexts or move to Redux |
| Need structured async data fetching     | Use Redux Toolkit                      |
| Need time travel debugging or dev tools | Redux                                  |
| Want simplicity + low setup             | Context                                |
