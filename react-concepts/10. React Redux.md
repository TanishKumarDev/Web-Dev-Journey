# React-Redux Introduction:

## Overview
**React-Redux** = Official React bindings for Redux, a predictable state container. It manages global app state centrally, syncing it with React components for efficient re-renders.

**Core Principles (Redux's "Three Laws"):**
- **Single Source of Truth:** All state in one immutable JS object (the store)—no duplicates.
- **State is Read-Only:** Can't mutate directly; only via dispatched actions (descriptive objects).
- **Changes via Pure Functions:** Reducers (pure funcs) take old state + action → new state (no side effects).

**Why It Matters (*Simple Terms*):**
- **Scalability:** Handles growing MERN apps (e.g., auth + cart + UI state) without chaos.
- **Debugging:** Time-travel in DevTools; logs every action.
- **MERN Link:** Dispatch actions on API calls (e.g., `dispatch(addToCart(itemFromMongo))`); reducers update UI seamlessly.

**Prerequisites:** React components, Context API from earlier notes; basic JS objects/arrays.

## Core Concepts of React-Redux
Redux's building blocks—master these for any setup.

### 1. Store
- **What It Is:** Single object holding all app state (e.g., `{ users: [], cart: [] }`).
- **Role:** Created once; only modified via dispatch. Subscribe components to it.
- **Example:** `const store = createStore(reducer);`—initializes with default state.

### 2. Actions
- **What It Is:** Plain JS objects describing "what happened" (e.g., `{ type: 'ADD_USER', payload: userData }`).
- **Key Props:** `type` (required string); `payload` (optional data).
- **Example:**
  ```js
  const incrementAction = {
    type: 'INCREMENT',
    payload: 1  // Optional data
  };
  ```
- **Explanation:** Actions are "events"—no logic; just signals. In MERN, payload could be API response.

### 3. Reducers
- **What It Is:** Pure function: `(state, action) => newState`. Handles one action type; immutable updates.
- **Rules:** Never mutate original; return default on unknown types.
- **Example (Counter Reducer):**
  ```js
  const counterReducer = (state = 0, action) => {  // Initial state: 0
    switch (action.type) {
      case 'INCREMENT':
        return state + action.payload;  // Immutable: new value
      case 'DECREMENT':
        return state - action.payload;
      default:
        return state;  // No change
    }
  };
  ```
- **Explanation:** Switch on `type`; spread for objects (`{ ...state, count: state.count + 1 }`). Pure = no randos/side effects.

### 4. Dispatch
- **What It Is:** Store method to send actions: `store.dispatch(action)`.
- **Role:** Triggers reducers; updates store → re-renders subscribed components.
- **Example:** `store.dispatch(incrementAction);`—flows to reducer.

### 5. Selectors
- **What It Is:** Functions extracting state slices: `const selectCount = (state) => state.count;`.
- **Role:** Abstracts access (e.g., `useSelector(selectCount)` in Hooks version—article focuses on class/connect, but Hooks are modern).
- **Best Practice:** Memoize with `reselect` for computed values (e.g., `totalCart = sum(items)`).

### 6. Provider
- **What It Is:** HOC wrapping app: `<Provider store={store}><App /></Provider>`.
- **Role:** Injects store via React Context—enables `connect` or `useSelector`.
- **Example:**
  ```jsx
  import { Provider } from 'react-redux';
  <Provider store={store}>
    <App />
  </Provider>
  ```

### 7. connect()
- **What It Is:** HOC linking components: `connect(mapStateToProps, mapDispatchToProps)(Component)`.
- **mapStateToProps:** `(state) => ({ propsFromState })`—subscribes to state.
- **mapDispatchToProps:** `(dispatch) => ({ func: () => dispatch(action) })`—binds actions.
- **Example (Counter Component):**
  ```jsx
  import { connect } from 'react-redux';

  const Counter = ({ count, increment }) => (  // Receives from maps
    <div>
      <h1>{count}</h1>
      <button onClick={increment}>Increment</button>
    </div>
  );

  const mapStateToProps = (state) => ({  // Pulls state
    count: state.count
  });

  const mapDispatchToProps = (dispatch) => ({  // Binds actions
    increment: () => dispatch({ type: 'INCREMENT', payload: 1 })
  });

  export default connect(mapStateToProps, mapDispatchToProps)(Counter);
  ```
- **Explanation:** Connect subscribes; on dispatch, only changed props re-render component. (Modern: Use Hooks like `useSelector/useDispatch`—simpler, no HOC.)

**Common Mistake:** Mutating state in reducer (e.g., `state.count++`—breaks immutability; use spread).

## React-Redux Working
Redux flow: Unidirectional loop for predictability. (Visual: Animation33 in article shows counter clicks.)

1. **Setup Store:** `createStore(reducer)`—holds initial state.
2. **Dispatch Action:** `dispatch({ type: 'INCREMENT' })`—sends to store.
3. **Reducer Processes:** Matches type, returns new state (immutable).
4. **Connect Components:** `mapState` pulls updates; components re-render if props change.
5. **Provider Enables:** Context makes store available tree-wide.
6. **Reactivity:** Virtual DOM diffs—only affected components update.

**Key Explanation:** Actions are declarative ("increment by 1"); reducers imperative ("how"). Ensures traceability.

**Best Practice:** Keep actions simple; slice reducers for big apps (combine with `combineReducers`).

## Steps to Implement React-Redux
Article's counter app demo—full MERN-ready skeleton.

### Step 1: Project Setup
- `npx create-react-app react-redux-counter && cd react-redux-counter`
- `npm install redux react-redux`
- **Folder Structure:** (Visual: cewf in article)
  ```
  src/
  ├── redux/
  │   ├── actionTypes.js
  │   ├── actions.js
  │   ├── reducer.js
  │   └── store.js
  ├── App.js
  └── index.js
  ```
- **Dependencies:** Redux ^5.0.1, React-Redux ^9.1.2 (as listed).

### Step 2: Define Action Types
**actionTypes.js:**
```js
export const INCREMENT = 'INCREMENT';
export const DECREMENT = 'DECREMENT';
```
- **Explanation:** Constants prevent typos; centralizes types.

### Step 3: Action Creators
**actions.js:**
```js
import { INCREMENT, DECREMENT } from "./actionTypes";

export const increment = () => ({  // Returns action object
  type: INCREMENT,
});

export const decrement = () => ({
  type: DECREMENT,
});
```
- **Explanation:** Functions for reusable actions (e.g., `dispatch(increment())`).

### Step 4: Reducers
**reducer.js:**
```js
import { INCREMENT, DECREMENT } from "./actionTypes";

const initialState = { count: 0 };  // Default state

const counterReducer = (state = initialState, action) => {
  switch (action.type) {
    case INCREMENT:
      return { ...state, count: state.count + 1 };  // Immutable spread
    case DECREMENT:
      return { ...state, count: state.count - 1 };
    default:
      return state;
  }
};

export default counterReducer;
```
- **Explanation:** Handles cases; spreads for objects—prevents mutation.

### Step 5: Create Store
**store.js:**
```js
import { createStore } from 'redux';
import counterReducer from './reducer';

const store = createStore(counterReducer);  // Initializes store

export default store;
```
- **Explanation:** `createStore` takes root reducer; export for Provider.

### Step 6: Wrap with Provider (index.js)
```jsx
import React from 'react';
import ReactDOM from 'react-dom/client';  // Modern v18
import { Provider } from 'react-redux';
import store from './redux/store';
import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <Provider store={store}>
    <App />  // All components now access store
  </Provider>
);
```
- **Run:** `npm start`—Output: Interactive counter (increment/decrement buttons; animation shows state change).

**App.js (Connect Component):**
```jsx
import React from 'react';
import { connect } from 'react-redux';
import { increment, decrement } from './redux/actions';

const App = ({ count, increment, decrement }) => (  // Props from connect
  <div>
    <h1>Count: {count}</h1>
    <button onClick={increment}>+</button>
    <button onClick={decrement}>-</button>
  </div>
);

const mapStateToProps = (state) => ({ count: state.count });

const mapDispatchToProps = (dispatch) => ({
  increment: () => dispatch(increment()),
  decrement: () => dispatch(decrement())
});

export default connect(mapStateToProps, mapDispatchToProps)(App);
```
- **Explanation:** Connects UI to store—clicks dispatch, reducer updates, component re-renders.

**Common Mistake:** Forgetting Provider—`connect` fails with null store.

## Step-by-Step Workflow: Building a Redux Counter App
1. **Setup Project:** Create app; install `redux react-redux`.
2. **Define Types/Actions:** Create `actionTypes.js` (strings); `actions.js` (creators returning objects).
3. **Build Reducer:** `reducer.js`—initial state; switch for cases; immutable returns.
4. **Create Store:** `store.js`—`createStore(reducer)`.
5. **Connect Component:** In `App.js`, use `connect(mapState, mapDispatch)`—pull state, bind actions.
6. **Wrap App:** `index.js`—`<Provider store={store}><App /></Provider>`.
7. **Test:** `npm start`; click buttons—verify count updates. Add console.log in reducer for flow.
8. **MERN Enhance:** Dispatch on fetch (e.g., `dispatch(loadUsers(dataFromExpress))`); use async thunks for APIs.
9. **Debug:** Install Redux DevTools extension—trace actions/time-travel.

## Best Practices
- **Immutability Always:** Use spread (`...state`) or Immer for deep updates.
- **Small Reducers:** Combine with `combineReducers` for slices (e.g., userReducer + cartReducer).
- **Action Creators:** Keep pure; use Redux Toolkit (RTK) for modern boilerplate reduction.
- **Selectors:** Memoize to avoid recalcs.
- **Hooks Over Connect:** Prefer `useSelector/useDispatch` in functional components—simpler.
- **MERN Tip:** Integrate RTK Query for API caching (fetches to Express/Mongo).

## Key Takeaways
- **Core Idea:** Redux = Centralized, predictable state via store (truth), actions (signals), reducers (updaters). React-Redux connects via Provider/connect.
- **Flow:** Dispatch action → Reducer → New state → Re-render (efficient via Virtual DOM).
- **Principles:** Single store, read-only, pure funcs—ensures debuggability.
- **When/Why:** Scale beyond Context; for MERN, manage API-synced state (e.g., carts from Mongo).
- **Remember This:** Start with RTK for new projects (simplifies code); always immutable updates. This elevates from Context (simple sharing) to pro state—next, async Redux for backend calls.
