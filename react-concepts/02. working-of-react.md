# **How React Works Under the Hood**

### **2.1 The Problem React Solves**

Before React:

* Every time your data changed, you manually updated the DOM with vanilla JS.
* Updating the DOM is **expensive**:

  * Browser recalculates layout, reflows, and repaints.
  * Multiple updates in quick succession lead to **slow, janky UIs**.

React solves this by:

1. **Virtual DOM** – lightweight in-memory representation of the UI.
2. **Diffing & Reconciliation** – only update what changed.
3. **Fiber architecture** – handles updates efficiently, making UI responsive.

---

### **2.2 The DOM vs Virtual DOM**

#### **DOM**

* Tree-like structure of HTML elements.
* Example:

```html
<html>
  <body>
    <h1>Hello</h1>
    <p>Welcome</p>
  </body>
</html>
```

* DOM Tree:

```
html
 └─ body
     ├─ h1
     └─ p
```

* Updating DOM is **slow**, because browser recalculates layout and repaints.

---

#### **Virtual DOM**

* **JS object representation of the DOM**.
* React maintains a Virtual DOM in memory.
* Updates happen in **Virtual DOM first**, then React calculates **minimal changes** to apply to the real DOM.

**Example:**

```js
const vdom = {
  type: "div",
  props: { className: "container", children: [
    { type: "h1", props: { children: "Hello" } },
    { type: "p", props: { children: "Welcome" } }
  ]}
};
```

* Efficient updates: only affected nodes are updated.

---

### **2.3 Reconciliation**

* Reconciliation = React comparing **old Virtual DOM vs new Virtual DOM** and applying minimal updates to the real DOM.
* Steps:

  1. Create a Virtual DOM from JSX.
  2. When **state or props change**, React creates a **new Virtual DOM**.
  3. Compare new VDOM vs old VDOM using **diffing algorithm**.
  4. Update only the parts of the real DOM that changed.

---

### **2.4 Diffing Algorithm**

**Key ideas:**

1. **Different types of elements:**

   * `<div>` → `<span>` → rebuild entire DOM subtree.

2. **Same type DOM element:**

   * Update only attributes that changed:

```jsx
<div className="before" title="stuff" />
<div className="after" title="stuff" />
```

3. **Same type Component element:**

   * Update state/props, reuse DOM nodes, don’t rebuild subtree.

4. **Children list changes:**

   * Adding/removing items at the **end** → efficient.
   * Adding/removing in the **middle** → could rebuild part of the list.
   * **Solution:** Use `key` prop for list items.

```jsx
<ul>
  {movies.map(movie => <li key={movie.id}>{movie.title}</li>)}
</ul>
```

---

### **2.5 Reconciliation Algorithms**

1. **Stack-based (React <16)**

   * Updates one at a time.
   * UI can become **unresponsive** during multiple state changes.
   * Intermediate states were visible.

2. **Fiber (React 16+)**

   * Updates **chunked into smaller units**.
   * Lane-based scheduling → prioritizes urgent updates.
   * Allows **smooth animations and responsiveness**.

**Takeaway:** Fiber is the reason React feels snappy even when apps are complex.

---

### **2.6 Mapping to Your Learning Project**

Your project folder:

```
└── src
    └── components
        ├── DashboardHeader.jsx
        ├── MoviePlaceholder.jsx
```

* **DashboardHeader.jsx** → simple component, virtual DOM example.
* **MoviePlaceholder.jsx** → dynamic list of movies → perfect for learning **diffing, keys, and reconciliation**.

**Example: Movie List**

```jsx
const movies = [
  { id: 1, title: "Inception" },
  { id: 2, title: "Avatar" },
];

function MoviePlaceholder({ movies }) {
  return (
    <ul>
      {movies.map(movie => (
        <li key={movie.id}>{movie.title}</li>
      ))}
    </ul>
  );
}
```

* Changing `movies` array → triggers **re-render**, React uses **diffing algorithm**.
* `key` ensures efficient update, only modified elements are touched.

---

### **2.7 Key Takeaways**

* **Virtual DOM** = performance optimization for real DOM.
* **Reconciliation** = intelligent comparison of old & new UI states.
* **Diffing Algorithm** = decides minimal changes.
* **Keys** = prevent unnecessary DOM rebuilds in lists.
* **Fiber** = modern engine for **concurrent, smooth updates**.

