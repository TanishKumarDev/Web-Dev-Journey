
# **Chapter 01: Fundamentals**


## **01. Introduction to React & Course Overview**

### **Theory / What & Why**

* **What is React?**
  React is a **free, open-source JavaScript library** for building user interfaces (UI). It focuses on creating reusable components for web apps.

* **Why React?**
  1. **Modular UI**: Breaks apps into small, reusable pieces (components).
  2. **Efficient Updates**: Uses Virtual DOM to update only changed parts, making apps fast.
  3. **Versatile**: "Learn once, write anywhere" – works for web, mobile (React Native), desktop.

* **Problems it Solves**:
  Traditional web dev involves manual DOM manipulation, leading to slow, buggy UIs. React handles rendering declaratively, reducing errors and improving performance.

* **Course Structure** (from transcript):
  - Fundamentals: 10 projects/exercises.
  - Advanced: Hooks, TypeScript, animations, testing, full-stack with Next.js/React Native.

### **Logic / How it Works**

* React apps are built as a **tree of components**.
* Core: JSX (HTML in JS) + Virtual DOM (in-memory representation) + Reconciliation (diffing changes).

### **Code Example**

No code yet – setup in next section.

### **File/Component Organization**

N/A for intro.

### **Notes & Best Practices**

1. **Prerequisites**: HTML/CSS (must), JavaScript (must, skip OOP if beginner), TypeScript (recommended), Tailwind CSS (optional but used for styling).
2. **Mindset**: Start small – build projects to reinforce. Don't download videos; support creators ethically.
3. **Old vs. New**: Skip old 2021 React course; this is updated.

**Mini Problem Solved** (Transcript: Recall prerequisites – no code, but apply thinking):
* **Problem**: List prerequisites and decide if you're ready.
* **Thinking**: Core issue: Missing basics block progress. Solution: Self-assess – if no JS, pause for JS review. Scalable: Build a checklist component later.
* **Solution**: Prerequisites component (hypothetical for mindset):
  ```jsx
  const Prerequisites = () => {
    const reqs = ["HTML", "CSS", "JavaScript", "TypeScript (opt)", "Tailwind (opt)"];
    return (
      <ul>
        {reqs.map((req) => <li key={req}>{req}</li>)}
      </ul>
    );
  };
  ```
  *Why?* Uses list rendering early; tests readiness by rendering dynamically.

---

## **02. Project Setup with Vite**

### **Theory / What & Why**

* **What is Setup?**
  Creating a new React project with a bundler like Vite for fast dev server, hot reload, and dependency management.

* **Why Vite?**
  1. **Fast**: ES modules for instant startup.
  2. **Modern**: Handles JSX/TS out-of-box.
  3. **Simple**: Fewer configs than Create React App.

* **Problems it Solves**:
  Manual boilerplate (HTML/JS setup) is tedious. Vite automates it for quick iteration.

### **Logic / How it Works**

* `npm create vite@latest`: Scaffolds project with React template.
* `npm install`: Installs deps (React, etc.).
* `npm run dev`: Starts dev server on localhost:5173.
* Files auto-wire: `main.jsx` renders `App.jsx` to `#root` in `index.html`.

### **Code Example**

**Terminal Commands**
```bash
npm create vite@latest react-demo
cd react-demo
npm install
code .  # Opens in VS Code
npm run dev
```

**Initial App.jsx (after cleanup)**
```jsx
// src/App.jsx
const App = () => {
  return <section>Hello World</section>;
};
export default App;
```

**main.jsx**
```jsx
// src/main.jsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App.jsx';

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
);
```

### **File/Component Organization**

```
react-demo/
├── public/          # Static assets (delete if unused)
├── src/
│   ├── assets/      # Images/SVGs
│   ├── App.jsx      # Main app component
│   ├── main.jsx     # Entry point (renders App to #root)
│   └── index.css    # Global styles (cleanup: remove if unused)
├── index.html       # Root HTML (#root div)
├── package.json     # Deps & scripts
├── vite.config.js   # Vite config
└── .gitignore       # Ignore node_modules, etc.
```

**Cleanup Steps**: Delete `public/`, `App.css`, `index.css`; simplify `App.jsx`.

### **Notes & Best Practices**

1. Use **VS Code** with extensions: ES7+ React/Redux snippets (type `rafce` for boilerplate).
2. **node_modules**: Auto-generated; don't commit (use `.gitignore`).
3. **Port**: Defaults to 5173; copy from terminal.
4. Test: Change `<section>Hello</section>` to `<section>My Name</section>` – refresh sees update.

**Mini Problem Solved** (Transcript: Run after cleanup – error if no export).
* **Problem**: "Hello" doesn't render – why? Missing export.
* **Thinking**: Core issue: Components need export/import to render. Solution: Add `export default App`. Scalable: Always export after defining; test with simple text.
* **Solution**:
  ```jsx
  // App.jsx (fixed)
  const App = () => <section>My Name</section>;
  export default App;  // Add this
  ```
  *Why?* Without export, `main.jsx` imports nothing – blank page. Refresh: Shows "My Name".

---

## **03. Components**

### **Theory / What & Why**

* **What is a Component?**
  Independent, reusable UI pieces (like JS functions returning JSX).

* **Why Components?**
  1. **Modularity**: Split UI into parts (e.g., navbar, card).
  2. **Reusability**: Use `<Card />` multiple times.
  3. **Separation of Concerns**: Logic/UI per component.

* **Problems it Solves**:
  Monolithic HTML/JS files are hard to maintain. Components enable scalable apps.

### **Logic / How it Works**

* Function/arrow function returning JSX.
* Uppercase name (e.g., `App`): React treats as custom component.
* Render: Import → Use as JSX tag → React mounts to DOM.

### **Code Example**

**App.jsx**
```jsx
// Function declaration
function App() {
  return <h1>Hello from Component</h1>;
}
// Or arrow function
const AppArrow = () => <h1>Hello Arrow</h1>;

export default App;  // Export to use elsewhere
```

**main.jsx** (renders it)
```jsx
import App from './App.jsx';
// ...
<App />  // Renders to #root
```

### **File/Component Organization**

```
src/
└── components/  # Folder for all components
    └── App.jsx
```

### **Notes & Best Practices**

1. **Naming**: PascalCase (e.g., `MovieCard`).
2. **Export**: `export default` for single; `export { Name }` for multiple.
3. **Single Responsibility**: One component = one UI/logic piece.
4. Arrow vs. Function: Arrow for brevity; both fine.

**Mini Problem Solved** (Transcript: Split Wikipedia UI into components).
* **Problem**: Break UI into reusable parts without code – pen/paper or Figma.
* **Thinking**: Core issue: Identify repeatable/isolated sections. Solution: Group by function (e.g., nav separate from content). Scalable: Nested components (e.g., Nav > Logo + Search). Edge: Avoid over-splitting small elements.
* **Solution** (Components list):
  - `BurgerMenu`: Icon + toggle logic.
  - `Navigation`: Logo, search, login/create.
  - `Banner`: Optional alert.
  - `Sidebar`: Filters/genres.
  - `Appearance`: Radio buttons for theme.
  - `Header`: Title/section.
  - `MainContent`: Articles/cards (reuse `Card`).
  *Why?* Reusability: `Card` for multiple articles. Test: Sketch – ensures modularity.

---

## **04. Creating & Rendering Components**

### **Theory / What & Why**

* **What:** Define, export, import, and render components in a tree.

* **Why:** Builds hierarchical UIs (e.g., App > Header > Nav).

* **Problems it Solves:** Scattered code; components organize into a render tree.

### **Logic / How it Works**

* Create: Function returning JSX.
* Export: `export default`.
* Import/Render: `<ComponentName />` in parent.
* VS Code Snippet: `rafce` generates boilerplate.

### **Code Example**

**components/Greet.jsx**
```jsx
// rafce snippet
import React from 'react';

const Greet = () => {
  return (
    <div>
      <h1>Hello from Greet</h1>
    </div>
  );
};

export default Greet;
```

**components/Add.jsx**
```jsx
import React from 'react';

const Add = () => <h1>Something Cool</h1>;

export default Add;
```

**App.jsx**
```jsx
import Greet from './components/Greet';
import Add from './components/Add';

const App = () => {
  return (
    <div>
      <Greet />
      <Add />
    </div>
  );
};

export default App;
```

### **File/Component Organization**

```
src/
└── components/  # All in one folder
    ├── Greet.jsx
    └── Add.jsx
```

### **Notes & Best Practices**

1. **Auto-import**: VS Code suggests on `<Greet />`.
2. **Folder**: `components/` for organization.
3. Test: Change text – re-renders only that component.

**Mini Problem Solved** (Transcript: Create Header/Main/Footer).
* **Problem**: Build 3 components; render in App.
* **Thinking**: Core: Structure (header/nav, main/content, footer/copyright). Solution: Each returns semantic HTML. Scalable: Props later for dynamic nav links. Edge: Ensure single parent.
* **Solution**:
  **Header.jsx**
  ```jsx
  const Header = () => (
    <header>
      <h1>Welcome to My Website</h1>
      <nav>
        <a href="/">Home</a>
        <a href="/about">About</a>
        <a href="/contact">Contact</a>
      </nav>
    </header>
  );
  export default Header;
  ```
  **Main.jsx**
  ```jsx
  const Main = () => (
    <main>
      <h2>Main Content</h2>
      <p>This is the main content.</p>
    </main>
  );
  export default Main;
  ```
  **Footer.jsx**
  ```jsx
  const Footer = () => (
    <footer>
      <p>&copy; 2025 My Website</p>
    </footer>
  );
  export default Footer;
  ```
  **App.jsx**: `<Header /><Main /><Footer />`
  *Why?* Semantic tags for accessibility. Test: Inspect – correct structure.

---

## **05. JSX**

### **Theory / What & Why**

* **What:** JSX = JavaScript + XML; write HTML-like code in JS.

* **Why:** Blends UI (HTML) with logic (JS) seamlessly.

* **Problems it Solves:** Pure JS for UI (`createElement`) is verbose; JSX is readable.

### **Logic / How it Works**

* Compiles to `React.createElement` calls.
* Embed JS: `{expression}`.
* Illusion of HTML – actually JS objects.

### **Code Example**

**App.jsx**
```jsx
const App = () => {
  return (
    <section id="section">
      <h1>My Website</h1>
      <article>
        <h2>Welcome to ReactJS</h2>
        <p className="text">Paragraph content</p>  {/* className, not class */}
      </article>
    </section>
  );
};
```

**Behind Scenes (Babel-transpiled)**
```jsx
React.createElement('section', { id: 'section' },
  React.createElement('h1', null, 'My Website'),
  React.createElement('article', null,
    React.createElement('h2', null, 'Welcome to ReactJS'),
    React.createElement('p', { className: 'text' }, 'Paragraph content')
  )
);
```

### **File/Component Organization**

JSX in any `.jsx` file; no separate folder.

### **Notes & Best Practices**

1. **className**: Not `class` (JS keyword).
2. Inspect: Confirms DOM match.
3. Keep JSX clean – logic outside.

**Mini Problem Solved** (Transcript: WelcomeMessage).
* **Problem**: Div > h1 "Hello World" + p "Welcome to learning JSX".
* **Thinking**: Core: Embed static text. Solution: Single parent `<div>`. Scalable: Add props later. Edge: Close all tags.
* **Solution**:
  ```jsx
  // WelcomeMessage.jsx
  const WelcomeMessage = () => (
    <div>
      <h1>Hello World</h1>
      <p>Welcome to learning JSX</p>
    </div>
  );
  export default WelcomeMessage;
  ```
  **App.jsx**: `<WelcomeMessage />`
  *Why?* Simple structure; renders correctly. Test: Add className – styles apply.

---

## **06. JSX Rules**

### **Theory / What & Why**

* **What:** Strict rules for valid JSX (e.g., single parent, camelCase).

* **Why:** Ensures compilation to JS without errors.

* **Problems it Solves:** Ambiguous code (e.g., `class` as JS keyword) causes runtime issues.

### **Logic / How it Works**

* Babel enforces: Single root, closed tags, camelCase attrs.
* Violate → Compile error.

### **Code Example**

**Valid JSX**
```jsx
const App = () => (
  <div>  {/* Single parent */}
    <h1 className="title">Hello</h1>  {/* camelCase */}
    <img src="img.png" alt="img" />  {/* Self-close */}
    <label htmlFor="input">Label</label>  {/* htmlFor */}
  </div>
);
```

**Invalid Examples (Errors)**
- Multiple roots: `<h1></h1><p></p>` → Error.
- `class="title"` → "Invalid prop 'class'".
- `<img src="img.png">` → "No closing tag".

### **File/Component Organization**

N/A – rules apply everywhere.

### **Notes & Best Practices**

1. **Fragment**: `<></>` for no extra div.
2. **Comments**: `{/* */}` inside JSX.
3. Debug: Console errors point to rule breaks.

**Mini Problem Solved** (Transcript: JSXRules with 3 paragraphs).
* **Problem**: Div > h1 "JSX Rules" + 3 p's on rules.
* **Thinking**: Core: Single parent, proper attrs. Solution: List rules as text. Scalable: Make dynamic later. Edge: No unclosed tags.
* **Solution**:
  ```jsx
  // JSXRules.jsx
  const JSXRules = () => (
    <div>
      <h1>JSX Rules</h1>
      <p>JSX must return a single parent element</p>
      <p>JSX elements must be properly closed</p>
      <p>JSX attributes are written using camelCase (e.g., className)</p>
    </div>
  );
  export default JSXRules;
  ```
  **App.jsx**: `<JSXRules />`
  *Why?* Enforces rules in code. Test: Remove `<div>` – error confirms single parent.

---

## **07. Expressions in JSX**

### **Theory / What & Why**

* **What:** Embed JS (vars, funcs, etc.) in JSX via `{}`.

* **Why:** Makes UI dynamic without separate templates.

* **Problems it Solves:** Static JSX can't handle vars/calculations; `{}` bridges JS/UI.

### **Logic / How it Works**

* `{}` evaluates JS expression → inserts result as text/attr.
* Supports: Vars, arithmetic, arrays (joins to string), funcs, objects (for attrs).

### **Code Example**

**App.jsx**
```jsx
const App = () => {
  const name = 'Husein Web Dev';
  const friends = ['Alex', 'John', 'Wah', 'Jordan'];
  const multiply = (a, b) => a * b;
  const specialClass = 'simple-class';

  return (
    <div>
      <p>2 + 2 = {2 + 2}</p>  {/* 4 */}
      <h1>{name}</h1>  {/* Dynamic var */}
      <p>My friends list: {friends.join(', ')}</p>  {/* Array */}
      <p>2 * 2 equals to {multiply(2, 2)}</p>  {/* Func */}
      <p className={specialClass}>Special class</p>  {/* Attr */}
    </div>
  );
};
```

### **File/Component Organization**

N/A.

### **Notes & Best Practices**

1. **Expressions only**: No statements (e.g., `if` inside `{}`).
2. **Arrays**: Use `.join()` or map for lists.
3. Dynamic attrs: `{condition ? 'class1' : 'class2'}`.

**Mini Problem Solved** (Transcript: Greetings + date; ProductInfo object).
* **Problem**: Greetings: h1 dynamic greeting + p date. ProductInfo: Render name/price/availability.
* **Thinking**: Core: `{var}` for embed. Solution: Use `new Date()` for date; object props. Scalable: Props for reusability. Edge: Format date (toString).
* **Solution**:
  **Greetings.jsx**
  ```jsx
  const Greetings = () => {
    const greet = 'Hello';
    return (
      <div>
        <h1>{greet}</h1>
        <p>Today's date: {new Date().toDateString()}</p>
      </div>
    );
  };
  export default Greetings;
  ```
  **ProductInfo.jsx**
  ```jsx
  const ProductInfo = () => {
    const product = { name: 'Laptop', price: 12200, availability: 'In Stock' };
    return (
      <div>
        <h1>{product.name}</h1>
        <p>Price: ${product.price}</p>
        <p>Availability: {product.availability}</p>
      </div>
    );
  };
  export default ProductInfo;
  ```
  **App.jsx**: `<Greetings /><ProductInfo />`
  *Why?* Dynamic: Change object – updates. Test: Console date; matches current.

---

## **08. Lists in React**

### **Theory / What & Why**

* **What:** Render arrays as lists using `.map()` to JSX.

* **Why:** Efficiently display dynamic collections (e.g., movies).

* **Problems it Solves:** Manual loops for lists are error-prone; `.map()` + keys optimize re-renders.

### **Logic / How it Works**

* `.map(item => <Component key={unique} {...item} />)`.
* **Key prop**: React's ID for diffing (stable, unique).

### **Code Example**

**App.jsx**
```jsx
const App = () => {
  const items = ['Item 1', 'Item 2', 'Item 3'];

  return (
    <ul>
      {items.map((item, index) => (
        <li key={index}>{item}</li>  // Key for efficiency
      ))}
    </ul>
  );
};
```

### **File/Component Organization**

N/A.

### **Notes & Best Practices**

1. **Keys**: Use ID, not index (if list sortable).
2. Empty list: `{list.length === 0 ? <p>No items</p> : list.map(...)}`.
3. Map to components for reusability.

**Mini Problem Solved** (Transcript: Render list – partial, but apply to friends array).
* **Problem**: Map friends array to <p> list.
* **Thinking**: Core: `.map()` generates elements. Solution: Key=index for static; join not needed. Scalable: Component per item. Edge: Empty array check.
* **Solution**:
  ```jsx
  // In App.jsx
  const friends = ['Alex', 'John', 'Wah', 'Jordan'];
  return (
    <div>
      <p>My friends:</p>
      {friends.length > 0 ? friends.map((friend, idx) => (
        <p key={idx}>{friend}</p>
      )) : <p>No friends</p>}
    </div>
  );
  ```
  *Why?* Renders list; key prevents warnings. Test: Add/remove – stable.

---

# **Summary Chapter 01: Fundamentals**

## **Overview**

Chapter 01 covers the **core building blocks of React**, including how to create components, manage data dynamically, handle events, and style your app. These fundamentals form the foundation for building any React application.

---

## **01. Components**

* **Definition:** Reusable building blocks of a React application.
* **Why:**

  * Reusability
  * Separation of concerns
  * Maintainability
* **Implementation:**

  * Functional components: `const MyComponent = () => { return <div>...</div> }`
  * One component per file → **PascalCase naming**
* **Best Practices:** Keep components **small, focused, and reusable**.

---

## **02. JSX**

* **Definition:** JSX = JavaScript XML, lets you **write HTML-like syntax inside JavaScript**.
* **Why:** Makes React code **declarative and readable**.
* **Rules:**

  * Return **single root element**
  * Use `{}` for embedding **JS expressions**
  * Use `className` instead of `class`
  * Self-close tags `<input />`
* **Problem Solved:** Without JSX, React components would need verbose `React.createElement` calls.

---

## **03. JSX Rules**

* **Single root element**
* **JS expressions in `{}`**
* **Comments:** `{/* comment */}`
* **Attributes:** camelCase (`onClick`, `htmlFor`)
* **Problem Solved:** Ensures JSX compiles cleanly into React elements.

---

## **04. Multiple Components**

* **Concept:** Compose UI using **several small components**.
* **Parent-child relationships** allow **data flow via props**.
* **Example Components:** Header, Footer, MovieCard
* **Best Practices:** One component per file, meaningful names, pass data via props.

---

## **05. Dynamic Content**

* **Definition:** Content that **changes based on variables, state, or props**.
* **Why:** Makes apps **interactive and personalized**.
* **Implementation:** Use `{variable}` inside JSX or map arrays to components.
* **Problem Solved:** Avoids manual DOM updates for dynamic content.

---

## **06. List of Data**

* **Definition:** Rendering **arrays of items** in React.
* **Key Points:**

  * Use `.map()` to iterate over arrays
  * Each element requires a **unique `key`**
* **Problem Solved:** Efficiently renders multiple items without repeating JSX manually.

---

## **07. Props**

* **Definition:** Inputs to components from parent → **dynamic, reusable components**.
* **Key Points:**

  * Read-only, cannot be modified in child
  * Can pass **any type**: string, number, array, object, function
* **Problem Solved:** Avoids hardcoded data inside components.

---

## **08. Prop Destructuring**

* **Definition:** Cleaner syntax to access props.
* **Implementation:**

  ```jsx
  const Component = ({ title, rating }) => { ... }
  ```
* **Problem Solved:** Avoids repetitive `props.xxx`, improves readability.

---

## **09. Props Children**

* **Definition:** Special prop `children` allows **passing JSX inside component tags**.
* **Why:** Makes components **flexible and composable** (e.g., Cards, Wrappers, Modals).
* **Problem Solved:** Avoids needing a separate prop for every piece of nested content.

---

## **10. Conditional Rendering**

* **Definition:** Render different UI based on **conditions**.
* **Ways:**

  * Ternary operator: `condition ? <A /> : <B />`
  * Logical AND: `condition && <A />`
  * If statements outside JSX
* **Problem Solved:** Dynamically shows/hides elements based on **state or props**.

---

## **11. Styles**

* **Ways to style React components:**

  1. CSS files (import into component)
  2. Inline styles (JS objects, camelCase)
  3. CSS Modules (scoped to component)
  4. Styled Components / CSS-in-JS
* **Best Practices:**

  * Keep global CSS for typography/layout
  * Component-specific styles → CSS Modules
  * Dynamic styles → inline

---

## **12. Events**

* **Definition:** Respond to **user interactions** (clicks, input, form submit).
* **Implementation:**

  * `onClick`, `onChange`, `onSubmit`
  * Pass **function reference**
* **Problem Solved:** React provides **SyntheticEvent** → consistent behavior across browsers.

---

## **13. State**

* **Definition:** Component-level data that **changes over time and triggers re-render**.
* **Implementation:**

  ```jsx
  const [count, setCount] = useState(0)
  ```
* **Best Practices:**

  * Keep state minimal and independent
  * Use functional updates when new state depends on previous state
  * Never mutate state directly

---

## **14. Portal**

* **Definition:** Render a component **outside its parent DOM hierarchy**.
* **Use Cases:** Modals, tooltips, popovers.
* **Implementation:** `ReactDOM.createPortal(child, container)`
* **Problem Solved:** Avoids CSS conflicts (overflow, z-index) while keeping React logic intact.

---

## **15. Advanced Keys**

* **Definition:** Keys uniquely identify list items.
* **Why:** Efficient re-rendering, preserves component state.
* **Best Practices:**

  * Use **stable unique IDs**
  * Avoid array index if list is dynamic
  * Keys are **not passed as props**

---

## ✅ **Key Takeaways**

* Components + Props + State → **Dynamic UI**
* Lists + Keys → **Efficient rendering**
* Conditional Rendering + Events → **Interactive applications**
* Styling → **Readable and maintainable UI**
* Portals → **Advanced rendering outside DOM hierarchy**
* **Chapter 01 forms the foundation** for **building any React application**.
