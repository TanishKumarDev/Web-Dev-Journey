# **Chapter 02:  → 01. React Hooks**

Hooks were introduced in **React 16.8** to allow **functional components** to manage **state, lifecycle, and side effects** without converting them into class components.
They fundamentally changed how modern React apps are built.

---

## **01. useState Hook**

### **1. What is useState?**

`useState` is a **React Hook** that allows functional components to **add and manage state** — just like `this.state` in class components.

**State** represents **dynamic data** that changes over time, like form inputs, counters, API responses, etc.

---

### **2. Why useState exists (Problem it solves)**

Before Hooks:

* Only **class components** could hold local state using `this.state`.
* Functional components were **stateless** — they could only render UI.

This led to:

* Verbose, less reusable code.
* Logic spread across lifecycle methods (`componentDidMount`, etc.).

**Solution:** `useState()` brings state to **functional components**, enabling clean, modular, and reusable logic.

---

### **3. Syntax and Explanation**

```jsx
import { useState } from "react";

const Example = () => {
  const [count, setCount] = useState(0);
  
  // count → current value of state
  // setCount → function to update count
  // 0 → initial value

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
};
```

* Each call to `useState()` **returns an array** `[stateValue, setFunction]`.
* You can **call setFunction()** to trigger a re-render with updated data.

---

### **4. Key Rules**

1. Hooks can only be used **inside functional components** or **custom hooks**.
2. Must be called **at the top level**, not inside loops or conditionals.
3. Each state variable is **independent** — call `useState` separately for each one.

---

### **5. When to use**

Use `useState` when you need to manage:

* UI toggles (like modal open/close)
* Input fields and form states
* Counters, timers
* Light/dark mode
* Any local (component-level) dynamic data

---

### **6. Advanced Logic: Functional Update**

If the new state depends on the **previous state**, use a callback form:

```jsx
setCount(prevCount => prevCount + 1);
```

This ensures correct updates even with async renders.

---

### **7. Example: Counter App (with Tailwind CSS)**

**File:** `/src/components/Counter.jsx`

```jsx
import { useState } from "react";

const Counter = () => {
  const [count, setCount] = useState(0);

  const increment = () => setCount(prev => prev + 1);
  const decrement = () => setCount(prev => prev - 1);
  const reset = () => setCount(0);

  return (
    <div className="flex flex-col items-center justify-center min-h-screen bg-gray-50 text-gray-800">
      <h1 className="text-3xl font-bold mb-6">React useState Example</h1>
      <div className="flex items-center gap-4">
        <button
          onClick={decrement}
          className="bg-red-500 text-white px-4 py-2 rounded-lg shadow-md hover:bg-red-600 transition"
        >
          -
        </button>
        <span className="text-2xl font-semibold">{count}</span>
        <button
          onClick={increment}
          className="bg-green-500 text-white px-4 py-2 rounded-lg shadow-md hover:bg-green-600 transition"
        >
          +
        </button>
      </div>
      <button
        onClick={reset}
        className="mt-6 bg-gray-500 text-white px-4 py-2 rounded-lg shadow hover:bg-gray-600 transition"
      >
        Reset
      </button>
    </div>
  );
};

export default Counter;
```

---

### **8. File Naming & Placement**

```
📁 src
 └── 📁 components
      └── Counter.jsx
```

* Name: `Counter.jsx`
* Naming: PascalCase for React components.
* Keep each demo component self-contained and reusable.

---

### **9. Common Mistakes**

❌ Updating state directly

```js
count = count + 1; // Wrong - won't trigger re-render
```

✅ Correct way

```js
setCount(count + 1);
```

❌ Calling useState conditionally

```js
if (someCondition) {
  const [data, setData] = useState(); // ❌ invalid
}
```

✅ Must be called at top level

```js
const [data, setData] = useState();
```

---

### **10. Summary Notes**

| Concept       | Explanation                                                        |
| ------------- | ------------------------------------------------------------------ |
| Hook          | Function that lets you use React features in functional components |
| useState      | Adds local state to a component                                    |
| setFunction   | Triggers re-render with updated value                              |
| Initial Value | Passed once, used only during first render                         |
| Re-render     | Occurs when state value changes                                    |
| Best Practice | Use separate state for logically distinct data                     |

---

### **11. Real Use Cases**

* Form input handling (email, password)
* Button toggle (show/hide password)
* Theme switching
* Pagination (current page)
* Modal visibility


---

# **Chapter 02 → 02. useEffect Hook**

---

## **1. What is useEffect?**

`useEffect` is a React Hook that allows you to **perform side effects** in functional components.

A **side effect** is any action that:

* Affects something outside the component, or
* Needs to run after render (not during rendering).

Examples:

* Fetching data from an API
* Working with browser APIs (`localStorage`, `document.title`, etc.)
* Subscribing/unsubscribing to events
* Timers (`setTimeout`, `setInterval`)

---

## **2. Why useEffect exists (The Problem Before It)**

Before Hooks:

* Side effects in React could only be handled with **class lifecycle methods**:

  * `componentDidMount`
  * `componentDidUpdate`
  * `componentWillUnmount`

Problems:

* Hard to **reuse logic** between components.
* Related code scattered across multiple lifecycle methods.
* Boilerplate-heavy and error-prone.

**Solution:**
`useEffect` unifies lifecycle management into **one single hook** — simple, predictable, reusable.

---

## **3. Syntax & Signature**

```jsx
useEffect(() => {
  // side effect logic
  return () => {
    // optional cleanup (runs before unmount or before next effect)
  };
}, [dependencies]);
```

### Parts Explained:

* **Effect Function** → runs after render.
* **Cleanup Function** → runs before re-running or unmounting.
* **Dependency Array** → tells React when to re-run the effect.

---

## **4. Execution Behavior**

| Dependency Array | When Effect Runs           | Example                          |
| ---------------- | -------------------------- | -------------------------------- |
| No array         | After every render         | useEffect(() => {...});          |
| Empty array `[]` | Only once (on mount)       | useEffect(() => {...}, []);      |
| `[variable]`     | When that variable changes | useEffect(() => {...}, [count]); |

---

## **5. Common Use Cases**

1. Fetching API data
2. Setting up subscriptions (WebSocket, Event Listeners)
3. DOM manipulations or animations
4. Updating `document.title`
5. Saving data to `localStorage`

---

## **6. Example 1: Basic useEffect**

```jsx
import { useState, useEffect } from "react";

const Example = () => {
  const [count, setCount] = useState(0);

  // Runs after every render
  useEffect(() => {
    console.log("Effect runs after render:", count);
  });

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
};

export default Example;
```

---

## **7. Example 2: Run Once (componentDidMount equivalent)**

```jsx
useEffect(() => {
  console.log("Runs only once when component mounts");

  // Example: Fetch API on load
  fetch("https://jsonplaceholder.typicode.com/posts")
    .then(res => res.json())
    .then(data => console.log(data));
}, []); // empty array
```

---

## **8. Example 3: Cleanup Function (componentWillUnmount)**

```jsx
useEffect(() => {
  const handleResize = () => console.log("Window resized");

  window.addEventListener("resize", handleResize);

  // Cleanup before component unmounts or before next run
  return () => {
    window.removeEventListener("resize", handleResize);
    console.log("Cleanup done");
  };
}, []);
```

---

## **9. Example 4: With Dependency Array**

```jsx
useEffect(() => {
  console.log("Count changed:", count);
}, [count]); // Only runs when count updates
```

---

## **10. Project Example: Fetch Movies List (with Tailwind UI)**

**File:** `/src/components/MovieList.jsx`

```jsx
import { useState, useEffect } from "react";

const MovieList = () => {
  const [movies, setMovies] = useState([]);
  const [loading, setLoading] = useState(true);

  // Fetch data when component mounts
  useEffect(() => {
    const fetchMovies = async () => {
      try {
        const res = await fetch("https://api.tvmaze.com/shows");
        const data = await res.json();
        setMovies(data.slice(0, 5)); // first 5 movies
      } catch (error) {
        console.error("Failed to fetch movies:", error);
      } finally {
        setLoading(false);
      }
    };

    fetchMovies();
  }, []); // run only once

  return (
    <div className="p-10 bg-gray-50 min-h-screen text-gray-800">
      <h1 className="text-3xl font-bold mb-6 text-center">Movies List</h1>

      {loading ? (
        <p className="text-center text-gray-500">Loading...</p>
      ) : (
        <div className="grid md:grid-cols-3 gap-6">
          {movies.map((movie) => (
            <div
              key={movie.id}
              className="bg-white shadow-md p-4 rounded-2xl hover:shadow-lg transition"
            >
              <img
                src={movie.image?.medium}
                alt={movie.name}
                className="rounded-xl mb-3 w-full"
              />
              <h2 className="text-xl font-semibold">{movie.name}</h2>
              <p className="text-sm text-gray-600">{movie.genres.join(", ")}</p>
            </div>
          ))}
        </div>
      )}
    </div>
  );
};

export default MovieList;
```

---

## **11. File Naming & Structure**

```
📁 src
 └── 📁 components
      ├── Counter.jsx
      └── MovieList.jsx
```

Each concept gets its own self-contained component for learning clarity.

---

## **12. Common Mistakes**

❌ Missing dependency array (runs endlessly)

```jsx
useEffect(() => {
  fetchData();
}); // ❌ will cause infinite loop
```

✅ Fix by specifying dependencies

```jsx
useEffect(() => {
  fetchData();
}, []); // ✅ runs once
```

❌ Using async directly inside useEffect

```jsx
useEffect(async () => {
  const res = await fetch(...); // ❌ Not allowed
});
```

✅ Correct way

```jsx
useEffect(() => {
  const fetchData = async () => {
    const res = await fetch(...);
  };
  fetchData();
}, []);
```

---

## **13. Summary Notes**

| Concept          | Description                                          |
| ---------------- | ---------------------------------------------------- |
| Side Effects     | External actions like API calls, timers, DOM updates |
| useEffect()      | Hook to manage side effects                          |
| Dependency Array | Controls when effect runs                            |
| Cleanup Function | Runs before component unmounts or before re-run      |
| Empty Array      | Mount-only effect                                    |
| Re-run Trigger   | Any variable in dependency list changes              |

---

## **14. Real-World Use Cases**

* Fetching data on page load
* Subscribing to WebSocket or Firebase streams
* Listening to DOM or window events
* Syncing data to `localStorage`
* Running animations on mount


---

# **Chapter 02 → 03. Prop Drilling**

## **1. What is Prop Drilling?**

**Definition:**
Prop drilling is the process of **passing data from a parent component to deeply nested child components** through **multiple layers of intermediate components** that *don’t actually need that data*.

In simple terms:

> “You keep passing props down and down just to reach a component that actually uses them.”

---

## **2. Why Prop Drilling Happens (The Problem)**

React’s data flow is **unidirectional (top-down)** — data can only move from parent to child using **props**.

This becomes a problem when:

* A deeply nested component needs access to data.
* The data must be passed through many “middle” components that don’t need it.

**Pain Points:**

* Cluttered and repetitive prop passing.
* Hard to maintain large component trees.
* Tight coupling — small changes break multiple layers.
* Readability issues — difficult to trace where data comes from.

---

## **3. Visual Understanding**

```
App.jsx
 ├── Header.jsx
 │    └── UserProfile.jsx
 │          └── UserDetails.jsx
```

Now if `App` holds the `user` data, and `UserDetails` needs it:

* `App` → passes `user` to `Header`
* `Header` → passes `user` to `UserProfile`
* `UserProfile` → passes `user` to `UserDetails`

Even though only `UserDetails` uses `user`.

---

## **4. Example: Prop Drilling in Action**

**File:** `/src/components/UserDetails.jsx`

```jsx
// Deeply nested child
const UserDetails = ({ user }) => {
  return (
    <div className="p-4 border rounded-lg bg-white">
      <h2 className="text-xl font-semibold">{user.name}</h2>
      <p className="text-gray-600">{user.email}</p>
    </div>
  );
};

export default UserDetails;
```

**File:** `/src/components/UserProfile.jsx`

```jsx
import UserDetails from "./UserDetails";

const UserProfile = ({ user }) => {
  return (
    <div className="p-6 bg-gray-50 border rounded-xl">
      <UserDetails user={user} />
    </div>
  );
};

export default UserProfile;
```

**File:** `/src/components/Header.jsx`

```jsx
import UserProfile from "./UserProfile";

const Header = ({ user }) => {
  return (
    <header className="bg-gray-100 p-4 shadow-md flex justify-between items-center">
      <h1 className="text-2xl font-bold">My Dashboard</h1>
      <UserProfile user={user} />
    </header>
  );
};

export default Header;
```

**File:** `/src/App.jsx`

```jsx
import Header from "./components/Header";

const App = () => {
  const user = {
    name: "Tanish",
    email: "tanish@example.com",
  };

  return (
    <div className="min-h-screen bg-gray-50">
      <Header user={user} />
    </div>
  );
};

export default App;
```

**Observation:**

* The `user` prop is drilled down through 3 components just to reach `UserDetails`.
* Intermediate components (`Header`, `UserProfile`) don’t actually use the data.

---

## **5. When Prop Drilling Becomes a Problem**

* More than 2–3 component levels deep.
* Shared data needed across *multiple branches* of the tree.
* Frequently updated global data (like user info, theme, auth).

---

## **6. When It’s Okay**

If you only pass data down **1 or 2 levels**, prop drilling is fine.
No need for complex state management.

---

## **7. Solution: Context API**

React introduced **Context API** to solve this — allowing data to be **shared globally** without prop drilling.

Instead of passing props through every component, Context lets components **access data directly** from a **shared provider**.

We’ll learn that in the **next topic** (Context & useContext).

---

## **8. Quick Example: Problem vs Solution**

**Prop Drilling**

```jsx
<App user={user}>
  <Header user={user}>
    <UserProfile user={user}>
      <UserDetails user={user} />
    </UserProfile>
  </Header>
</App>
```

**Context Solution (Preview)**

```jsx
<UserContext.Provider value={user}>
  <Header />
</UserContext.Provider>
```

Now `UserDetails` can access `user` directly using `useContext(UserContext)`
No prop passing in between.

---

## **9. Real-World Example**

* **Theme toggling (light/dark mode)** — shared across entire app.
* **User authentication info (JWT, roles)** — needed everywhere.
* **Language preferences (i18n)** — required in many nested components.

Without context, all of these create huge prop chains.

---

## **10. File Naming & Folder Structure**

```
📁 src
 └── 📁 components
      ├── Header.jsx
      ├── UserProfile.jsx
      ├── UserDetails.jsx
 ├── App.jsx
```

Each file uses **PascalCase** for components and clean prop management for clarity.

---

## **11. Summary Notes**

| Concept         | Description                                                 |
| --------------- | ----------------------------------------------------------- |
| Prop Drilling   | Passing data down through multiple components unnecessarily |
| Cause           | React’s one-way data flow                                   |
| Problem         | Maintenance complexity, redundant props                     |
| When okay       | For small component trees                                   |
| Better solution | Context API or global store (Redux, Zustand)                |

---

## **12. Practice Task**

Try building a small UI:

* **Parent Component:** Holds theme (“light” / “dark”).
* **Nested Components:** 3 levels deep, each showing the theme.
* Pass `theme` using props manually — feel the pain of drilling.

---

# **Chapter 02 → 04. Context API (with useContext)**

## **1. What is Context API?**

**Definition:**
The **Context API** in React provides a way to **share data globally** across components **without prop drilling**.

It allows you to:

* Create a **Context (global store)**.
* Provide data at a higher level in the component tree.
* Access that data from any nested component directly.

---

## **2. Why Context Exists (Problem it solves)**

React components share data via **props**, but that becomes painful when:

* Many nested components need the same data.
* You must pass the same props repeatedly through intermediaries.

Example:

* `user` info, `theme`, or `language` used in multiple components.
* Without Context → You drill props through 5–6 layers.
* With Context → You provide data once and access anywhere.

In essence:

> Context = Global shared state for React components.

---

## **3. Core Concepts**

| Term                    | Description                                    |
| ----------------------- | ---------------------------------------------- |
| `React.createContext()` | Creates a Context object                       |
| `Context.Provider`      | Makes data available to all children           |
| `useContext(Context)`   | Hook to consume the context value              |
| `Context.Consumer`      | (Old method) — use only if you can’t use hooks |

---

## **4. Syntax Overview**

```jsx
import { createContext, useContext } from "react";

// 1. Create context
const UserContext = createContext();

// 2. Provider component
<UserContext.Provider value={user}>
  <ChildComponent />
</UserContext.Provider>

// 3. Consume context anywhere
const user = useContext(UserContext);
```

---

## **5. How it Works (Step-by-Step)**

1. Create a **context** using `createContext()`.
2. Wrap the top-level (or relevant parent) component in a **Provider**.
3. Pass the data (value) to the `Provider`.
4. Access that data from **any nested child** using `useContext()` — no props required.

---

## **6. Practical Example: User Data Without Prop Drilling**

### **Folder Setup**

```
📁 src
 └── 📁 context
      └── UserContext.jsx
 └── 📁 components
      ├── Header.jsx
      ├── UserProfile.jsx
      ├── UserDetails.jsx
 ├── App.jsx
```

---

### **Step 1: Create the Context**

**File:** `/src/context/UserContext.jsx`

```jsx
import { createContext } from "react";

// Create a new context object
export const UserContext = createContext(null);
```

---

### **Step 2: Provide Context at Top Level**

**File:** `/src/App.jsx`

```jsx
import { UserContext } from "./context/UserContext";
import Header from "./components/Header";

const App = () => {
  const user = {
    name: "Tanish",
    email: "tanish@example.com",
    role: "Frontend Developer",
  };

  return (
    // Provide 'user' to all nested components
    <UserContext.Provider value={user}>
      <div className="min-h-screen bg-gray-50">
        <Header />
      </div>
    </UserContext.Provider>
  );
};

export default App;
```

---

### **Step 3: Consume Context in a Deeply Nested Component**

**File:** `/src/components/UserDetails.jsx`

```jsx
import { useContext } from "react";
import { UserContext } from "../context/UserContext";

const UserDetails = () => {
  const user = useContext(UserContext); // consume context

  return (
    <div className="p-6 bg-white border rounded-2xl shadow-md text-center">
      <h2 className="text-2xl font-bold text-gray-800">{user.name}</h2>
      <p className="text-gray-600">{user.email}</p>
      <p className="text-sm text-gray-500 italic">{user.role}</p>
    </div>
  );
};

export default UserDetails;
```

---

### **Step 4: Intermediate Components (No prop passing anymore)**

**File:** `/src/components/UserProfile.jsx`

```jsx
import UserDetails from "./UserDetails";

const UserProfile = () => {
  return (
    <div className="p-8 bg-gray-100 rounded-xl">
      <UserDetails />
    </div>
  );
};

export default UserProfile;
```

**File:** `/src/components/Header.jsx**

```jsx
import UserProfile from "./UserProfile";

const Header = () => {
  return (
    <header className="bg-gray-200 p-4 shadow-md flex justify-between items-center">
      <h1 className="text-2xl font-semibold">My Dashboard</h1>
      <UserProfile />
    </header>
  );
};

export default Header;
```

---

### **Step 5: Output**

✅ `UserDetails` accesses `user` **directly** using `useContext`.
✅ No prop drilling from `App → Header → UserProfile → UserDetails`.

---

## **7. Example with Tailwind UI**

Here’s what the app looks like visually:

```jsx
<div className="min-h-screen bg-gradient-to-br from-blue-50 to-purple-50 flex flex-col items-center justify-center">
  <Header />
</div>
```

`UserDetails` will show a clean card-like profile view.

Tailwind makes it visually intuitive — you focus on logic, not CSS noise.

---

## **8. When to Use Context**

✅ Perfect for:

* Auth / Current User Info
* Global Themes (light/dark)
* Language (i18n)
* App-wide configuration
* Shared state between distant components

❌ Avoid for:

* Frequently changing local state (it can cause unnecessary re-renders)
* Very large data — consider Redux, Zustand, or Jotai

---

## **9. Common Mistakes**

❌ Using context without wrapping a Provider

```jsx
const user = useContext(UserContext); // ❌ undefined if not wrapped
```

✅ Must wrap with Provider

```jsx
<UserContext.Provider value={...}>
  <App />
</UserContext.Provider>
```

❌ Passing new object every render → causes re-renders
✅ Memoize values if necessary:

```jsx
const value = useMemo(() => ({ user, logout }), [user]);
<UserContext.Provider value={value}>...</UserContext.Provider>
```

---

## **10. Summary Notes**

| Concept       | Description                                               |
| ------------- | --------------------------------------------------------- |
| Context API   | Provides a global way to share data without prop drilling |
| Provider      | Supplies data to components below it                      |
| useContext    | Hook to consume the data from context                     |
| createContext | Creates the global store                                  |
| Cleanup       | Not needed here, unless combined with effects             |
| Common Use    | Auth, Theme, Language, Config                             |

---

## **11. Real-World Use Cases**

1. **Theme Management:** Light/Dark mode switch.
2. **Auth System:** Current user info and tokens.
3. **Global Alert/Toast Messages**
4. **Language Translator / Multi-language apps**
5. **Cart Context in eCommerce apps**

---

## **12. Folder & Naming Standard**

```
📁 src
 ├── 📁 context
 │    └── UserContext.jsx
 ├── 📁 components
 │    ├── Header.jsx
 │    ├── UserProfile.jsx
 │    └── UserDetails.jsx
 ├── App.jsx
```

* Context files in `/context` folder.
* Components in `/components`.
* PascalCase naming.
* Clean imports (relative paths).

---

## **13. Practice Task**

Build a **ThemeContext**:

* Two buttons — “Light Mode” and “Dark Mode”.
* Theme applied across all components using `useContext`.
* Bonus: Persist theme using `localStorage`.
Perfect 👌


---

# **Chapter 02 → 05. useReducer Hook (with useContext Integration)**


## 🧠 **1. What is `useReducer`?**

`useReducer` is a React Hook used to **manage complex state logic** in a predictable and structured way.

It’s like an **advanced useState** where:

* State transitions depend on **actions**.
* The logic for changing state is centralized inside a **reducer function**.

---

## ⚙️ **2. Syntax**

```jsx
const [state, dispatch] = useReducer(reducer, initialState);
```

* `state` → current state.
* `dispatch` → function used to send actions.
* `reducer` → function describing *how* state changes.
* `initialState` → initial value of state.

---

## 🔍 **3. Reducer Function Structure**

A **reducer** is just a pure function that takes in:

1. The current state
2. An action (object)
3. Returns a **new state**

```jsx
function reducer(state, action) {
  switch (action.type) {
    case "increment":
      return { count: state.count + 1 };
    case "decrement":
      return { count: state.count - 1 };
    case "reset":
      return { count: 0 };
    default:
      return state;
  }
}
```

---

## 🧩 **4. When to Use `useReducer`**

✅ Best for:

* Complex state transitions
* Multiple related state values
* When next state depends on previous one
* When you need predictable updates (like Redux logic)

❌ Avoid for:

* Simple state updates (use `useState` instead)

---

## 🧠 **5. Concept Flow (Mental Model)**

Think of `useReducer` as a **state machine**:

```
dispatch(action) --> reducer(state, action) --> newState
```

The state changes **only** through the reducer function — making it predictable and easy to debug.

---

## 🧪 **6. Example 1: Counter App (Basic)**

**Goal:** Build a counter with `+`, `-`, and `Reset` buttons.

---

### **Code: App.jsx**

```jsx
import { useReducer } from "react";

const initialState = { count: 0 };

function reducer(state, action) {
  switch (action.type) {
    case "increment":
      return { count: state.count + 1 };
    case "decrement":
      return { count: state.count - 1 };
    case "reset":
      return { count: 0 };
    default:
      return state;
  }
}

const App = () => {
  const [state, dispatch] = useReducer(reducer, initialState);

  return (
    <div className="min-h-screen flex flex-col items-center justify-center bg-gradient-to-r from-blue-50 to-purple-50">
      <div className="bg-white p-10 rounded-2xl shadow-xl text-center">
        <h1 className="text-3xl font-bold mb-4 text-gray-800">Counter App</h1>
        <p className="text-4xl font-semibold text-blue-600 mb-6">{state.count}</p>

        <div className="flex gap-4">
          <button
            onClick={() => dispatch({ type: "increment" })}
            className="px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600"
          >
            +
          </button>
          <button
            onClick={() => dispatch({ type: "decrement" })}
            className="px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600"
          >
            -
          </button>
          <button
            onClick={() => dispatch({ type: "reset" })}
            className="px-4 py-2 bg-gray-400 text-white rounded-lg hover:bg-gray-500"
          >
            Reset
          </button>
        </div>
      </div>
    </div>
  );
};

export default App;
```

---

### **🧠 Breakdown**

| Step                            | Action         | State Change |
| ------------------------------- | -------------- | ------------ |
| dispatch({ type: "increment" }) | → reducer runs | count++      |
| dispatch({ type: "decrement" }) | → reducer runs | count--      |
| dispatch({ type: "reset" })     | → reducer runs | count = 0    |

Everything is **pure**, predictable, and traceable.

---

## 🌍 **7. Example 2: useReducer + useContext (Global State)**

Let’s integrate `useReducer` with `useContext` to build a **global theme manager** (Light/Dark Mode).

---

### **Folder Setup**

```
📁 src
 ├── 📁 context
 │    └── ThemeContext.jsx
 ├── App.jsx
 ├── ThemeToggle.jsx
```

---

### **Step 1: Create ThemeContext**

**File:** `/src/context/ThemeContext.jsx`

```jsx
import { createContext, useReducer } from "react";

const ThemeContext = createContext();

const initialState = { theme: "light" };

function reducer(state, action) {
  switch (action.type) {
    case "TOGGLE_THEME":
      return { theme: state.theme === "light" ? "dark" : "light" };
    default:
      return state;
  }
}

export const ThemeProvider = ({ children }) => {
  const [state, dispatch] = useReducer(reducer, initialState);

  return (
    <ThemeContext.Provider value={{ state, dispatch }}>
      {children}
    </ThemeContext.Provider>
  );
};

export default ThemeContext;
```

---

### **Step 2: App.jsx**

```jsx
import { useContext } from "react";
import ThemeContext, { ThemeProvider } from "./context/ThemeContext";
import ThemeToggle from "./ThemeToggle";

const ThemedView = () => {
  const { state } = useContext(ThemeContext);

  return (
    <div
      className={`min-h-screen flex flex-col items-center justify-center transition-all duration-500 ${
        state.theme === "light" ? "bg-gray-100 text-gray-900" : "bg-gray-900 text-gray-100"
      }`}
    >
      <h1 className="text-3xl font-bold mb-4">Current Theme: {state.theme}</h1>
      <ThemeToggle />
    </div>
  );
};

const App = () => (
  <ThemeProvider>
    <ThemedView />
  </ThemeProvider>
);

export default App;
```

---

### **Step 3: ThemeToggle.jsx**

```jsx
import { useContext } from "react";
import ThemeContext from "./context/ThemeContext";

const ThemeToggle = () => {
  const { dispatch } = useContext(ThemeContext);

  return (
    <button
      onClick={() => dispatch({ type: "TOGGLE_THEME" })}
      className="px-6 py-3 mt-4 rounded-lg bg-indigo-500 text-white font-semibold hover:bg-indigo-600 transition"
    >
      Toggle Theme
    </button>
  );
};

export default ThemeToggle;
```

---

### **💡 Output**

* Initially Light mode
* Click “Toggle Theme” → switches to Dark mode
* All components re-render with new theme
* Global state managed cleanly by `useReducer + useContext`

---

## 🧩 **8. Comparison: useState vs useReducer**

| Feature        | useState               | useReducer                         |
| -------------- | ---------------------- | ---------------------------------- |
| State Type     | Simple                 | Complex / multiple fields          |
| Update         | Direct setter          | Via actions (dispatch)             |
| Logic Location | Inline                 | Centralized reducer                |
| Ideal For      | Simple toggles, inputs | Forms, global state, complex logic |

---

## ⚡ **9. Common Mistakes**

❌ Returning wrong data structure
✅ Always return a **new state object**, not just a primitive.

❌ Mutating state directly
✅ Never modify — always return a new object.

```jsx
// ❌ Wrong
state.count++
return state;

// ✅ Correct
return { count: state.count + 1 };
```

---

## 🧭 **10. Summary Notes**

| Concept                 | Description                              |
| ----------------------- | ---------------------------------------- |
| useReducer              | Hook for managing complex state          |
| reducer                 | Pure function defining state transitions |
| dispatch                | Function used to trigger actions         |
| action                  | Object defining what change to make      |
| useContext + useReducer | Mini Redux pattern for global state      |

---

## 🧠 **11. Practice Tasks**

✅ **Task 1:**
Build a “To-Do List” using `useReducer`.
Actions → `ADD_TODO`, `DELETE_TODO`, `TOGGLE_TODO`.

✅ **Task 2:**
Integrate with `useContext` → make todos globally accessible.

✅ **Task 3 (Advanced):**
Persist data using `localStorage` + Tailwind UI for a clean layout.

---

Alright. Let’s move to the next major hook that introduces **direct interaction with the DOM** and **persistent mutable values without re-rendering** — the **`useRef` Hook**.

---

# **Chapter 02 → 06. useRef Hook**

---

## **1. The Problem Before `useRef`**

Before React Hooks, accessing or remembering DOM nodes or mutable values required:

* Class components with `createRef()`
* State variables that caused **unnecessary re-renders**

**Problem example:**

```jsx
const [count, setCount] = useState(0);

// Suppose we want to track how many times a component renders
let renders = 0;
renders++; // resets every re-render → incorrect tracking
```

Here, we lose the previous value each time — because **variables reset on each render**.

We also don’t want to store such data in state, because that would **trigger re-renders unnecessarily**.

→ **`useRef` exists to solve both these problems.**

---

## **2. What is `useRef`?**

`useRef` is a React Hook that:

* Returns a **mutable object** (`{ current: ... }`)
* **Persists its value across renders**
* **Does not trigger re-renders** when updated

**Syntax:**

```jsx
const ref = useRef(initialValue);
```

`ref.current` gives access to the current value.

---

## **3. Two Core Use Cases**

| Use Case                   | Description                                               |
| -------------------------- | --------------------------------------------------------- |
| 1️⃣ DOM Access             | To directly access and manipulate DOM elements            |
| 2️⃣ Persist Mutable Values | To store values across renders without causing re-renders |

---

## **4. Example 1: Accessing the DOM**

### Goal:

Focus an input field automatically when the component loads, and again when clicking a button.

---

### Code: `App.jsx`

```jsx
import { useEffect, useRef } from "react";

const App = () => {
  const inputRef = useRef(null);

  useEffect(() => {
    // Automatically focus input when component mounts
    inputRef.current.focus();
  }, []);

  const handleFocus = () => {
    inputRef.current.focus();
  };

  return (
    <div className="min-h-screen flex flex-col items-center justify-center bg-gray-50">
      <div className="bg-white shadow-md p-8 rounded-xl w-80 text-center">
        <h2 className="text-xl font-bold mb-4 text-gray-700">Focus Input Demo</h2>
        <input
          ref={inputRef}
          type="text"
          placeholder="Type here..."
          className="w-full border border-gray-300 rounded-lg px-4 py-2 mb-4 focus:outline-none focus:ring-2 focus:ring-blue-400"
        />
        <button
          onClick={handleFocus}
          className="bg-blue-500 text-white px-4 py-2 rounded-lg hover:bg-blue-600"
        >
          Focus Again
        </button>
      </div>
    </div>
  );
};

export default App;
```

---

### **Explanation:**

* `useRef(null)` → creates a ref to hold the DOM node.
* `ref={inputRef}` → attaches that ref to the `<input>` element.
* `inputRef.current` → gives access to the DOM node.
* On `useEffect` mount → automatically focuses input.

This allows **direct DOM manipulation safely** without using `document.querySelector()` (which breaks React’s virtual DOM abstraction).

---

## **5. Example 2: Persistent Value (Stopwatch)**

### Goal:

Track elapsed seconds without causing re-renders every tick.

---

### Code: `Stopwatch.jsx`

```jsx
import { useEffect, useRef, useState } from "react";

const Stopwatch = () => {
  const [seconds, setSeconds] = useState(0);
  const intervalRef = useRef(null);

  const startTimer = () => {
    if (intervalRef.current !== null) return; // prevent multiple intervals
    intervalRef.current = setInterval(() => {
      setSeconds((prev) => prev + 1);
    }, 1000);
  };

  const stopTimer = () => {
    clearInterval(intervalRef.current);
    intervalRef.current = null;
  };

  const resetTimer = () => {
    stopTimer();
    setSeconds(0);
  };

  useEffect(() => {
    return () => clearInterval(intervalRef.current);
  }, []);

  return (
    <div className="min-h-screen flex items-center justify-center bg-gradient-to-br from-gray-100 to-gray-300">
      <div className="bg-white p-8 rounded-2xl shadow-md text-center">
        <h1 className="text-3xl font-bold mb-4 text-gray-700">Stopwatch</h1>
        <p className="text-4xl font-semibold mb-6">{seconds}s</p>
        <div className="flex gap-3 justify-center">
          <button
            onClick={startTimer}
            className="bg-green-500 text-white px-4 py-2 rounded-lg hover:bg-green-600"
          >
            Start
          </button>
          <button
            onClick={stopTimer}
            className="bg-yellow-500 text-white px-4 py-2 rounded-lg hover:bg-yellow-600"
          >
            Stop
          </button>
          <button
            onClick={resetTimer}
            className="bg-red-500 text-white px-4 py-2 rounded-lg hover:bg-red-600"
          >
            Reset
          </button>
        </div>
      </div>
    </div>
  );
};

export default Stopwatch;
```

---

### **Logic:**

* `intervalRef` stores the timer ID (mutable but not causing re-renders).
* We use `setSeconds()` only when displaying the value — React re-renders only then.
* Clearing interval on unmount prevents memory leaks.

---

## **6. Comparison: `useState` vs `useRef`**

| Feature                         | `useState` | `useRef` |
| ------------------------------- | ---------- | -------- |
| Triggers re-render              | ✅ Yes      | ❌ No     |
| Persistent value across renders | ✅ Yes      | ✅ Yes    |
| Used for DOM access             | ❌ No       | ✅ Yes    |
| Good for UI state               | ✅ Yes      | ❌ No     |
| Stores mutable data             | ❌ No       | ✅ Yes    |

---

## **7. Real-World Use Cases**

1. **Focus Management:**
   Automatically focus input fields (login, OTP, search bars).
2. **Interval / Timer Storage:**
   Avoid multiple intervals (as shown above).
3. **Accessing Previous Value:**
   Track previous prop/state values between renders.
4. **Integrating with Non-React Libraries:**
   e.g., accessing Canvas, Chart.js, or Mapbox DOM elements.

---

## **8. Example: Store Previous Value**

```jsx
import { useEffect, useRef, useState } from "react";

const PreviousValue = () => {
  const [count, setCount] = useState(0);
  const prevCount = useRef(null);

  useEffect(() => {
    prevCount.current = count; // update after every render
  }, [count]);

  return (
    <div className="flex flex-col items-center justify-center min-h-screen bg-gray-50">
      <h1 className="text-2xl font-bold mb-4">Previous Value Tracker</h1>
      <p className="mb-2">Current: {count}</p>
      <p className="text-gray-500 mb-4">Previous: {prevCount.current}</p>
      <button
        onClick={() => setCount(count + 1)}
        className="bg-blue-500 text-white px-4 py-2 rounded-lg hover:bg-blue-600"
      >
        Increment
      </button>
    </div>
  );
};

export default PreviousValue;
```

---

## **9. Key Takeaways**

* `useRef` is **not reactive** — updating `.current` won’t re-render.
* Perfect for storing **mutable values** that should persist between renders.
* Use with caution: avoid replacing state logic with refs unnecessarily.
* React keeps the same ref object throughout component lifecycle.

---

## **10. Practice Tasks**

✅ Build an **OTP input component** where:

* On typing in one box, focus moves to the next automatically (via `useRef`).

✅ Extend **Stopwatch** to display laps stored in a list.

✅ Use `useRef` to **scroll to bottom** of a chat box when new messages appear.

---

# **Chapter 02 → 07. Custom Hooks**

---

## **1. The Problem Before Custom Hooks**

When you use built-in hooks like `useState`, `useEffect`, `useRef`, etc. in **multiple components**, you might notice **repetitive logic**.

Example problem:
You fetch data in 3 components — Users, Products, Movies.
Each one has:

```jsx
const [data, setData] = useState([]);
const [loading, setLoading] = useState(true);
useEffect(() => {
  fetch(url)
    .then(res => res.json())
    .then(data => {
      setData(data);
      setLoading(false);
    });
}, []);
```

This repetition is **inefficient** and **hard to maintain**.

→ **Custom Hooks** solve this by **extracting logic into reusable functions**.

---

## **2. What Are Custom Hooks?**

A **Custom Hook** is simply a **JavaScript function** that:

* Starts with `"use"` (naming convention)
* Can call **other React hooks**
* Encapsulates reusable logic

---

### **Syntax**

```jsx
function useSomething() {
  // useState, useEffect, useRef, etc.
  return { ... };
}
```

Then use it like a normal hook:

```jsx
const { data, loading } = useSomething();
```

---

## **3. Why Custom Hooks Exist**

| Problem                              | Solution (Custom Hook)         |
| ------------------------------------ | ------------------------------ |
| Repeated logic across components     | Extract once, reuse everywhere |
| Messy components with too many hooks | Clean separation of logic      |
| Hard to test and maintain            | Test hooks independently       |

---

## **4. Rule of Hooks Reminder**

✅ Must follow React’s **Rules of Hooks**:

1. Always start with `use` (e.g., `useFetch`, `useLocalStorage`).
2. Must be called **at the top level** (not inside loops, conditions).
3. Can call **other hooks** (built-in or custom).
4. Must be used **inside functional components or other custom hooks**.

---

## **5. Example 1: useFetch Hook**

Let’s build a **reusable data fetching hook** that:

* Manages loading and error states
* Works for any API URL

---

### Folder Structure

```
📁 src
 ├── 📁 hooks
 │    └── useFetch.js
 ├── App.jsx
 ├── components/
 │    ├── UserList.jsx
 │    └── MovieList.jsx
```

---

### **useFetch.js**

```jsx
import { useEffect, useState } from "react";

export default function useFetch(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    let isMounted = true; // to prevent state update after unmount
    setLoading(true);

    fetch(url)
      .then((res) => {
        if (!res.ok) throw new Error("Failed to fetch data");
        return res.json();
      })
      .then((data) => {
        if (isMounted) {
          setData(data);
          setLoading(false);
        }
      })
      .catch((err) => {
        if (isMounted) {
          setError(err.message);
          setLoading(false);
        }
      });

    return () => {
      isMounted = false; // cleanup
    };
  }, [url]);

  return { data, loading, error };
}
```

---

### **UserList.jsx**

```jsx
import useFetch from "../hooks/useFetch";

const UserList = () => {
  const { data: users, loading, error } = useFetch(
    "https://jsonplaceholder.typicode.com/users"
  );

  if (loading) return <p className="text-center text-gray-600">Loading users...</p>;
  if (error) return <p className="text-center text-red-500">Error: {error}</p>;

  return (
    <div className="p-6 bg-white shadow rounded-xl">
      <h2 className="text-xl font-bold mb-4 text-gray-700">Users</h2>
      <ul className="space-y-2">
        {users.map((user) => (
          <li key={user.id} className="border-b pb-2">
            {user.name} - <span className="text-gray-500">{user.email}</span>
          </li>
        ))}
      </ul>
    </div>
  );
};

export default UserList;
```

---

### **MovieList.jsx**

```jsx
import useFetch from "../hooks/useFetch";

const MovieList = () => {
  const { data: movies, loading, error } = useFetch(
    "https://dummyapi.online/api/movies"
  );

  if (loading) return <p className="text-center text-gray-600">Loading movies...</p>;
  if (error) return <p className="text-center text-red-500">Error: {error}</p>;

  return (
    <div className="p-6 bg-white shadow rounded-xl mt-6">
      <h2 className="text-xl font-bold mb-4 text-gray-700">Movies</h2>
      <ul className="space-y-2">
        {movies.map((movie) => (
          <li key={movie.id} className="border-b pb-2">
            {movie.movie} ({movie.rating})
          </li>
        ))}
      </ul>
    </div>
  );
};

export default MovieList;
```

---

### **App.jsx**

```jsx
import UserList from "./components/UserList";
import MovieList from "./components/MovieList";

const App = () => {
  return (
    <div className="min-h-screen bg-gray-100 flex flex-col items-center justify-start py-10">
      <h1 className="text-3xl font-bold mb-6">Custom Hook Demo</h1>
      <UserList />
      <MovieList />
    </div>
  );
};

export default App;
```

---

### **Result**

* Both components use the same logic.
* Each one handles **different API endpoints**.
* Clean, reusable, easy to maintain.

---

## **6. Example 2: useLocalStorage Hook**

A hook to sync React state with `localStorage` (commonly used in dashboards, dark mode toggles, etc.)

---

### **useLocalStorage.js**

```jsx
import { useEffect, useState } from "react";

export default function useLocalStorage(key, initialValue) {
  const [value, setValue] = useState(() => {
    const storedValue = localStorage.getItem(key);
    return storedValue ? JSON.parse(storedValue) : initialValue;
  });

  useEffect(() => {
    localStorage.setItem(key, JSON.stringify(value));
  }, [key, value]);

  return [value, setValue];
}
```

---

### **Example Usage**

```jsx
import useLocalStorage from "../hooks/useLocalStorage";

const ThemeToggle = () => {
  const [theme, setTheme] = useLocalStorage("theme", "light");

  const toggleTheme = () => setTheme(theme === "light" ? "dark" : "light");

  return (
    <div
      className={`min-h-screen flex flex-col items-center justify-center ${
        theme === "light" ? "bg-gray-100 text-black" : "bg-gray-900 text-white"
      }`}
    >
      <h1 className="text-2xl font-bold mb-4">Theme: {theme}</h1>
      <button
        onClick={toggleTheme}
        className="px-6 py-3 bg-indigo-500 text-white rounded-lg hover:bg-indigo-600"
      >
        Toggle Theme
      </button>
    </div>
  );
};

export default ThemeToggle;
```

---

## **7. Example 3: usePrevious Hook**

Store and access the **previous state value** of any variable.

---

```jsx
import { useEffect, useRef } from "react";

export default function usePrevious(value) {
  const ref = useRef();
  useEffect(() => {
    ref.current = value;
  }, [value]);
  return ref.current;
}
```

**Usage:**

```jsx
const [count, setCount] = useState(0);
const prevCount = usePrevious(count);
```

---

## **8. Best Practices**

1. **Name must start with `use`**
   React uses this to track hooks internally.
2. **Return only what’s needed** (values/functions).
3. **Keep them focused** – one concern per hook.
4. **Don’t mix too many hooks** inside; keep them modular.
5. **Test individually** – easier to debug than components.

---

## **9. Real-World Custom Hooks**

| Hook              | Purpose                         |
| ----------------- | ------------------------------- |
| `useFetch`        | Data fetching logic             |
| `useLocalStorage` | Persistent state                |
| `useTheme`        | Manage dark/light theme         |
| `useWindowSize`   | Responsive UI logic             |
| `useDebounce`     | Delay API calls / search typing |
| `usePrevious`     | Store previous state            |
| `useOnlineStatus` | Detect network changes          |

---

## **10. Summary**

| Concept     | Description                                                  |
| ----------- | ------------------------------------------------------------ |
| Custom Hook | Function to reuse React logic                                |
| Benefits    | Cleaner, reusable, testable code                             |
| Example     | useFetch, useLocalStorage, usePrevious                       |
| Rules       | Must start with `use`, call hooks only at top level          |
| Used In     | Data fetching, local storage, responsiveness, authentication |

---

## **11. Practice Tasks**

✅ Create a `useToggle` hook to manage boolean states (like show/hide password).
✅ Create a `useOnlineStatus` hook to detect if the user is offline.
✅ Refactor one old component to extract logic into a custom hook.

---

# **Chapter 02 → 08. useId Hook**

---

## **1. The Problem Before `useId`**

When building forms or UI components that need **unique IDs**:

* You often write something like:

```jsx
<label htmlFor="input1">Name:</label>
<input id="input1" type="text" />
```

* But in **reusable components**, hardcoding IDs causes **duplicates** if multiple components render the same inputs.
* This breaks **accessibility** and can cause **React warnings** in SSR environments.

Problem Example:

```jsx
function InputField() {
  return (
    <>
      <label htmlFor="name">Name:</label>
      <input id="name" />
    </>
  );
}

// Rendering twice:
<InputField />
<InputField />
// Both inputs now have same id="name" → not safe
```

---

## **2. What is `useId`?**

`useId` is a **built-in React Hook** (React 18+) that generates **unique, stable IDs** for components, ensuring:

* No duplication
* Works in SSR and hydration
* Perfect for **labels, form elements, ARIA attributes**

**Syntax:**

```jsx
const id = useId();
```

`id` is a **unique string**, guaranteed to be stable across renders.

---

## **3. When to Use `useId`**

✅ Forms with `<label>` and `<input>`
✅ Associating ARIA attributes for accessibility
✅ Unique keys in components that don’t depend on data
✅ SSR + hydration-safe unique IDs

---

## **4. Basic Example**

```jsx
import { useId } from "react";

const InputField = ({ label }) => {
  const id = useId(); // generate unique id

  return (
    <div className="mb-4">
      <label htmlFor={id} className="block text-gray-700 font-medium mb-1">
        {label}
      </label>
      <input
        id={id}
        type="text"
        className="w-full border border-gray-300 rounded-lg px-4 py-2 focus:outline-none focus:ring-2 focus:ring-blue-400"
      />
    </div>
  );
};

export default InputField;
```

**Usage:**

```jsx
<InputField label="First Name" />
<InputField label="Last Name" />
```

✅ Each input now gets a **unique ID** automatically — no collisions.

---

## **5. Advanced Example: Accessible Radio Group**

```jsx
import { useId } from "react";

const ColorSelector = () => {
  const groupId = useId(); // unique id for the group
  const colors = ["Red", "Green", "Blue"];

  return (
    <fieldset className="mb-6">
      <legend className="font-bold mb-2">Select a color</legend>
      {colors.map((color) => {
        const id = `${groupId}-${color}`;
        return (
          <div key={color} className="flex items-center gap-2 mb-1">
            <input type="radio" id={id} name={groupId} value={color} />
            <label htmlFor={id}>{color}</label>
          </div>
        );
      })}
    </fieldset>
  );
};

export default ColorSelector;
```

* `groupId` ensures **all inputs are grouped correctly**.
* `id`s are **unique per color** but still deterministic and SSR-safe.

---

## **6. Why `useId` is Better than `Math.random()` or Incrementing Counters**

| Approach            | Problem                              | Benefit of useId                                           |
| ------------------- | ------------------------------------ | ---------------------------------------------------------- |
| `Math.random()`     | Changes on every render → breaks SSR | Stable, deterministic                                      |
| Incremental counter | Must be managed manually             | Automatic, safe across renders                             |
| useId               | ✅                                    | Generates unique, stable IDs for forms and ARIA attributes |

---

## **7. Best Practices**

1. Always use `useId` for **form inputs inside reusable components**.
2. Combine `useId` with **component-specific strings** if multiple IDs are needed inside a component.
3. **Do not use useId for dynamic lists** as key values; use array IDs for that.

---

## **8. Practice Tasks**

1. Build a **Login Form** with Email and Password using `useId` for inputs and labels.
2. Build a **RadioGroup** or **CheckboxGroup** component for preferences using `useId`.
3. Refactor any old reusable input components to be SSR-safe using `useId`.

---

## **9. Summary Notes**

| Concept  | Description                                         |
| -------- | --------------------------------------------------- |
| useId    | React Hook to generate unique, stable IDs           |
| Use Case | Forms, labels, ARIA attributes, SSR-safe components |
| Benefits | Avoid collisions, predictable, accessible           |
| Example  | `<input id={useId()} />`                            |

---

# **Summary Chapter 02 → React Hooks and State**

---

## **Overview**

React Hooks are **special functions** that allow **functional components** to have **state, lifecycle methods, and side effects**, which were earlier only possible in class components. Hooks enable:

* Cleaner, modular code
* Reusable logic
* Predictable state management
* Easier testing and maintainability

Hooks start with `use` and must follow **Rules of Hooks**:

1. Only call hooks at the top level of components or other hooks
2. Only call hooks from React functions (components or custom hooks)
3. Maintain consistent order of hook calls

---

## **01. useState**

* **Purpose:** Manage state in functional components
* **Why:** Before Hooks, state was only in class components
* **Syntax:**

```jsx
const [state, setState] = useState(initialValue);
```

* **Example:** Counter, toggle button
* **Key Points:**

  * Updates trigger re-renders
  * Use functional updates when next state depends on previous
* **Best Practice:** Keep state minimal and relevant

---

## **02. useEffect**

* **Purpose:** Handle side effects in functional components (API calls, timers, DOM updates)
* **Why:** Replaces lifecycle methods (componentDidMount, componentDidUpdate, componentWillUnmount)
* **Syntax:**

```jsx
useEffect(() => {
  // effect code
  return () => cleanup();
}, [dependencies]);
```

* **Example:** Fetch data on mount, event listeners
* **Key Points:**

  * Empty dependency array → runs once on mount
  * Cleanup function prevents memory leaks
* **Best Practice:** Always clean up subscriptions, intervals, or listeners

---

## **03. Prop Drilling & Context**

* **Prop Drilling Problem:** Passing props through multiple levels of components becomes messy
* **Solution:** React Context API
* **Context Steps:**

  1. Create Context
  2. Provide value at top-level
  3. Consume with `useContext` in children
* **Use Case:** Global theme, authentication, settings
* **Key Points:** Avoid overusing context to prevent unnecessary re-renders

---

## **04. useReducer**

* **Purpose:** Manage complex or multi-field state
* **Why:** `useState` becomes messy with multiple related state fields
* **Syntax:**

```jsx
const [state, dispatch] = useReducer(reducer, initialState);
```

* **Reducer Function:**

```jsx
function reducer(state, action) {
  switch(action.type) {
    case "increment": return { count: state.count + 1 };
    default: return state;
  }
}
```

* **Example:** Counter, global theme, forms
* **Best Practice:** Keep reducer pure, return new state object, centralize logic

---

## **05. useRef**

* **Purpose:**

  1. Access DOM elements directly
  2. Persist mutable values across renders without triggering re-renders
* **Why:** State is reactive; some values don’t need re-renders
* **Syntax:**

```jsx
const ref = useRef(initialValue);
```

* **Use Cases:** Input focus, timers, previous values, DOM integration
* **Best Practice:** Avoid using refs for reactive UI logic; use state instead

---

## **06. Custom Hooks**

* **Purpose:** Extract and reuse logic across multiple components
* **Why:** Avoid repetitive hook usage in multiple components
* **Naming:** Must start with `use`
* **Syntax:**

```jsx
function useCustomHook() {
  const [state, setState] = useState();
  useEffect(() => {...}, []);
  return { state, setState };
}
```

* **Examples:**

  * `useFetch` → reusable data fetching
  * `useLocalStorage` → persist state to localStorage
  * `usePrevious` → track previous value
* **Best Practice:** One concern per hook, return only what’s needed, test hooks independently

---

## **07. useId**

* **Purpose:** Generate unique, stable IDs for inputs, labels, ARIA attributes
* **Why:** Hardcoded IDs cause collisions and SSR issues
* **Syntax:**

```jsx
const id = useId();
```

* **Use Cases:** Forms, radio/checkbox groups, SSR-friendly components
* **Best Practice:** Combine with component-specific strings if multiple IDs are needed

---

## **Comparison Table of Hooks**

| Hook         | Purpose             | Triggers Re-render     | Key Feature                                |
| ------------ | ------------------- | ---------------------- | ------------------------------------------ |
| useState     | Manage state        | ✅ Yes                  | Simple state                               |
| useEffect    | Side effects        | ❌ No                   | Lifecycle methods in functional components |
| useContext   | Access global state | ✅ When context changes | Avoid prop drilling                        |
| useReducer   | Complex state       | ✅ Yes                  | Centralized reducer logic                  |
| useRef       | Mutable DOM/data    | ❌ No                   | Persistent, non-reactive value             |
| Custom Hooks | Reusable logic      | ✅/❌ depends            | Modular logic across components            |
| useId        | Unique IDs          | ❌ No                   | SSR-safe unique IDs                        |

---

## **Best Practices for Hooks**

1. Follow rules of hooks
2. Use `useReducer` for complex state, `useState` for simple state
3. Clean up in `useEffect`
4. Use `useRef` for DOM or mutable non-reactive values
5. Keep custom hooks modular and reusable
6. Use `useId` for accessibility and SSR-safe components
7. Avoid overusing context to prevent unnecessary re-renders

---

## **Practice / Integration Ideas**

* Build a **Counter App** using `useState` and `useReducer`
* Build **Theme Manager** using `useContext + useReducer`
* Build **Stopwatch** using `useRef`
* Build **Data Fetching App** using `useFetch` custom hook
* Use `useId` in **forms and radio groups**
* Combine multiple hooks in a single **Dashboard Component** with Tailwind styling

---

# **React Components: Types & Differences**

React components are **the building blocks of UI**. They take **props** and return **JSX** to render UI.

There are **mainly 3 types**:

---

## **1. Functional Components (Modern, Recommended)**

* **Definition:** A plain JavaScript function that returns JSX.
* **Can use Hooks** (`useState`, `useEffect`, etc.)
* **Simpler, more readable, easier to test**

**Syntax:**

```jsx
// Example
const MovieItem = ({ movie }) => {
  return (
    <li>
      {movie.title} ({movie.rating}/5)
    </li>
  );
};
```

**Key Points:**

* Lightweight, easy to read
* Can use **all hooks** → `useState`, `useEffect`, `useRef`, `useId`, custom hooks
* Recommended in **modern React projects**
* Easier to debug and optimize

**Use in Project:**

* `MovieItem.jsx`
* `DashboardHeader.jsx`
* `AddMovieForm.jsx`
* `Filter.jsx`

All of our Movie Dashboard components are **functional components**.

---

## **2. Class Components (Legacy)**

* **Definition:** ES6 class extending `React.Component`
* Can have **state** and **lifecycle methods** (`componentDidMount`, etc.)
* **Hooks cannot be used here**

**Syntax:**

```jsx
import React, { Component } from "react";

class MovieItem extends Component {
  render() {
    const { movie } = this.props;
    return (
      <li>
        {movie.title} ({movie.rating}/5)
      </li>
    );
  }
}
```

**Key Points:**

* Verbose → more boilerplate (`render()` method)
* Harder to reuse logic compared to functional + hooks
* Rarely used in **new React apps**
* Useful only if maintaining **legacy code** or older React versions (<16.8)

**Use Cases:** Old projects or libraries requiring classes.

---

## **3. Higher-Order Components (HOC)**

* **Definition:** A function that takes a component and **returns a new enhanced component**
* Often used for **reusable logic**, like authentication or analytics

**Syntax:**

```jsx
const withLogger = (WrappedComponent) => {
  return (props) => {
    console.log("Rendering:", WrappedComponent.name);
    return <WrappedComponent {...props} />;
  };
};

// Usage
const MovieItemWithLogger = withLogger(MovieItem);
```

**Key Points:**

* Logic reuse without changing original component
* Can wrap multiple components
* HOCs are **less common now** because **custom hooks** often replace them

**Use Case in Project:** Could wrap `MovieList` to log whenever movies render.

---

## **4. Render Props**

* **Definition:** Technique where a component **accepts a function as a prop** and calls it to render JSX
* Alternative to HOCs for **logic reuse**

**Syntax:**

```jsx
const MovieProvider = ({ render }) => {
  const movies = ["Avengers", "Iron Man"];
  return <div>{render(movies)}</div>;
};

// Usage
<MovieProvider render={(movies) => (
  <ul>{movies.map(movie => <li>{movie}</li>)}</ul>
)} />
```

**Key Points:**

* Less popular now with **hooks**
* Can replace HOCs in some scenarios
* Great for **dynamic render logic**

---

## **5. Component Type Summary Table**

| Component Type | Syntax                               | State        | Hooks      | When to Use                          | Example in Project    |
| -------------- | ------------------------------------ | ------------ | ---------- | ------------------------------------ | --------------------- |
| Functional     | `const Comp = () => {}`              | ✅ useState   | ✅ Yes      | Modern React, simple & readable      | `AddMovieForm`        |
| Class          | `class Comp extends React.Component` | ✅ this.state | ❌ No       | Legacy code or lifecycle-heavy tasks | Rarely needed         |
| HOC            | `const NewComp = hoc(OldComp)`       | Depends      | Depends    | Reusable logic for many components   | Logging wrapper       |
| Render Props   | `<Comp render={() => JSX} />`        | ✅ optional   | ✅ optional | Share rendering logic dynamically    | Conditional MovieList |

---

## **6. Key Differences (Functional vs Class)**

| Feature      | Functional                   | Class                                  |
| ------------ | ---------------------------- | -------------------------------------- |
| Syntax       | Simple, short                | Verbose, requires `render()`           |
| State        | `useState` / `useReducer`    | `this.state`                           |
| Side Effects | `useEffect`                  | `componentDidMount`, etc.              |
| Lifecycle    | Hooks-based                  | Class methods                          |
| Logic Reuse  | Custom Hooks                 | HOCs / Render Props                    |
| Performance  | Slightly better, lighter     | Slightly heavier due to class overhead |
| Popularity   | Modern projects, recommended | Legacy / old projects                  |

---

## **7. Why Functional + Hooks is Preferred**

* Less boilerplate → easier to read & maintain
* Logic reuse with **custom hooks** → replaces HOCs & Render Props
* Works seamlessly with modern **React ecosystem** (SSR, Suspense, concurrent mode)
* Recommended by React team

---

## **8. Movie Dashboard Example of Component Types**

| Component       | Type       | Reason                                          |
| --------------- | ---------- | ----------------------------------------------- |
| MovieItem       | Functional | Simple display, reusable, hooks optional        |
| DashboardHeader | Functional | No complex state, theme toggle handled via prop |
| AddMovieForm    | Functional | Needs `useState`, `useRef`, `useId`             |
| MovieList       | Functional | List rendering, conditional rendering           |
| Filter          | Functional | Simple controlled select input                  |

**Note:** We are using **functional everywhere**, which is **best practice for new projects**.

---