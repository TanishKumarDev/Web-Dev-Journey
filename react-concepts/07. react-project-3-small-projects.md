# **Project 1: Counter App**

### **Goal**

Build a simple counter that can increment, decrement, and reset — mastering **useState** and component reactivity.

---

## **1. What Are We Building?**

A counter that:

* Displays a number
* Has `+`, `-`, and `Reset` buttons
* Updates instantly on click

---

## **2. Concepts Covered**

* **Functional Components**
* **useState Hook**
* **Event Handling**
* **State Updates**
* **Tailwind Styling**

---

## **3. Folder Structure**

```
counter-app/
 ┣ src/
 ┃ ┣ components/
 ┃ ┃ ┗ Counter.jsx
 ┃ ┗ App.jsx
 ┣ index.js
 ┣ package.json
 ┗ tailwind.css
```

---

## **4. Logic Breakdown (Thinking like a React Dev)**

| Step | Logic                           | Why                          |
| ---- | ------------------------------- | ---------------------------- |
| 1    | Create a `Counter` component    | Modular, reusable            |
| 2    | Define a state variable `count` | Reactivity                   |
| 3    | Create handler functions        | Maintain clean logic         |
| 4    | Render buttons and count        | UI layer                     |
| 5    | Use Tailwind for styling        | Modern look, no CSS overhead |

---

## **5. Code Implementation**

### **`Counter.jsx`**

```jsx
import React, { useState } from "react";

const Counter = () => {
  // 1. Create state variable
  const [count, setCount] = useState(0);

  // 2. Handler functions
  const increment = () => setCount(prev => prev + 1);
  const decrement = () => setCount(prev => prev - 1);
  const reset = () => setCount(0);

  // 3. JSX + Tailwind styling
  return (
    <div className="min-h-screen flex flex-col justify-center items-center bg-gray-100">
      <h1 className="text-3xl font-semibold mb-6 text-gray-800">React Counter</h1>

      <div className="bg-white p-6 rounded-2xl shadow-md flex flex-col items-center">
        <p className="text-5xl font-bold mb-6 text-blue-600">{count}</p>

        <div className="flex gap-4">
          <button
            onClick={decrement}
            className="px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600 transition"
          >
            -
          </button>

          <button
            onClick={reset}
            className="px-4 py-2 bg-gray-300 text-gray-700 rounded-lg hover:bg-gray-400 transition"
          >
            Reset
          </button>

          <button
            onClick={increment}
            className="px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition"
          >
            +
          </button>
        </div>
      </div>
    </div>
  );
};

export default Counter;
```

### **`App.jsx`**

```jsx
import React from "react";
import Counter from "./components/Counter";

const App = () => {
  return <Counter />;
};

export default App;
```

---

## **6. Explanation (Step-by-Step Thinking)**

1. **`useState(0)`** — initializes `count` with 0.

   * React re-renders the component whenever `setCount` updates it.
2. **Button Handlers:**

   * `increment`: increases count
   * `decrement`: decreases count
   * `reset`: sets back to 0
3. **Each click → triggers re-render** → updated `count` reflects immediately.
4. **Tailwind** adds minimal modern UI without writing CSS manually.

---

## **7. Why This Project Matters**

| Concept               | Real-world Usage                                  |
| --------------------- | ------------------------------------------------- |
| `useState`            | Local UI changes (e.g., likes, toggles, counters) |
| Event handling        | Core interaction logic                            |
| State re-render       | Understanding React’s reactivity                  |
| Component composition | Fundamental to every React project                |

---

## **8. Possible Enhancements**

| Enhancement                  | Concept Used                |
| ---------------------------- | --------------------------- |
| Add limit (0–10)             | Conditional rendering       |
| Add color change on negative | Dynamic className           |
| Save count in localStorage   | `useEffect` for persistence |
| Add “+2” and “-2” buttons    | Parameterized updates       |

---

## **9. Final Notes**

* This project trains **core React reflexes** — state updates, rendering, event handling.
* Always think **“state → UI → interaction → update”**.
* This same logic scales up into **Todo Lists**, **Filters**, **APIs**, and **E-commerce** components.
---

# **Project 2: Todo App**

---

## **1. Objective**

We’ll build a **Todo List Application** that allows users to:

* Add new tasks
* Mark tasks as complete
* Delete tasks
* (Optional) Persist tasks in `localStorage` using `useEffect`

---

## **2. Concepts Covered**

| Concept               | Description                                     |
| --------------------- | ----------------------------------------------- |
| useState              | For managing tasks list and input state         |
| useEffect             | For saving/loading tasks (persistence)          |
| useRef                | For auto-focusing input                         |
| Components            | Clean structure — TodoInput, TodoList, TodoItem |
| Conditional Rendering | Display “No tasks” message                      |
| Tailwind              | Styling and layout                              |

---

## **3. Folder Structure**

```
todo-app/
 ┣ src/
 ┃ ┣ components/
 ┃ ┃ ┣ TodoInput.jsx
 ┃ ┃ ┣ TodoList.jsx
 ┃ ┃ ┗ TodoItem.jsx
 ┃ ┗ App.jsx
 ┣ index.js
 ┣ tailwind.css
```

---

## **4. Step-by-Step Logic (What, Why, How)**

| Step | Task                                     | Reason            |
| ---- | ---------------------------------------- | ----------------- |
| 1    | Create state `todos`                     | Store all tasks   |
| 2    | Create input to add new todos            | User interaction  |
| 3    | Map through todos to render list         | Dynamic rendering |
| 4    | Add “complete” and “delete” actions      | Update state      |
| 5    | Save in `localStorage` using `useEffect` | Data persistence  |
| 6    | Use `useRef` for better UX (focus)       | Improve usability |

---

## **5. Code Implementation**

### **`TodoInput.jsx`**

```jsx
import React, { useState, useRef } from "react";

const TodoInput = ({ addTodo }) => {
  const [task, setTask] = useState("");
  const inputRef = useRef(null);

  const handleAdd = () => {
    if (task.trim() === "") return;
    addTodo(task);
    setTask("");
    inputRef.current.focus();
  };

  return (
    <div className="flex gap-3 mt-6">
      <input
        ref={inputRef}
        type="text"
        placeholder="Enter a task..."
        value={task}
        onChange={(e) => setTask(e.target.value)}
        className="flex-1 border rounded-lg px-4 py-2 focus:outline-none focus:ring-2 focus:ring-blue-400"
      />
      <button
        onClick={handleAdd}
        className="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition"
      >
        Add
      </button>
    </div>
  );
};

export default TodoInput;
```

---

### **`TodoItem.jsx`**

```jsx
import React from "react";

const TodoItem = ({ todo, toggleComplete, deleteTodo }) => {
  return (
    <div
      className={`flex justify-between items-center bg-white rounded-lg p-3 mb-2 shadow-sm border-l-4 ${
        todo.completed ? "border-green-500" : "border-blue-500"
      }`}
    >
      <p
        onClick={() => toggleComplete(todo.id)}
        className={`flex-1 cursor-pointer ${
          todo.completed ? "line-through text-gray-500" : "text-gray-800"
        }`}
      >
        {todo.text}
      </p>

      <button
        onClick={() => deleteTodo(todo.id)}
        className="text-red-500 hover:text-red-700 transition"
      >
        ✕
      </button>
    </div>
  );
};

export default TodoItem;
```

---

### **`TodoList.jsx`**

```jsx
import React from "react";
import TodoItem from "./TodoItem";

const TodoList = ({ todos, toggleComplete, deleteTodo }) => {
  if (todos.length === 0)
    return (
      <p className="text-gray-500 text-center mt-6">No tasks yet. Add one above!</p>
    );

  return (
    <div className="mt-6 w-full">
      {todos.map((todo) => (
        <TodoItem
          key={todo.id}
          todo={todo}
          toggleComplete={toggleComplete}
          deleteTodo={deleteTodo}
        />
      ))}
    </div>
  );
};

export default TodoList;
```

---

### **`App.jsx`**

```jsx
import React, { useState, useEffect } from "react";
import TodoInput from "./components/TodoInput";
import TodoList from "./components/TodoList";

const App = () => {
  const [todos, setTodos] = useState(() => {
    // Load from localStorage
    const saved = localStorage.getItem("todos");
    return saved ? JSON.parse(saved) : [];
  });

  // Add new task
  const addTodo = (text) => {
    const newTodo = {
      id: Date.now(),
      text,
      completed: false,
    };
    setTodos((prev) => [...prev, newTodo]);
  };

  // Toggle complete
  const toggleComplete = (id) => {
    setTodos((prev) =>
      prev.map((todo) =>
        todo.id === id ? { ...todo, completed: !todo.completed } : todo
      )
    );
  };

  // Delete todo
  const deleteTodo = (id) => {
    setTodos((prev) => prev.filter((todo) => todo.id !== id));
  };

  // Persist todos
  useEffect(() => {
    localStorage.setItem("todos", JSON.stringify(todos));
  }, [todos]);

  return (
    <div className="min-h-screen bg-gray-100 flex flex-col items-center py-10 px-4">
      <h1 className="text-3xl font-bold text-blue-700 mb-6">React Todo App</h1>
      <div className="w-full max-w-md bg-gray-50 p-6 rounded-2xl shadow-md">
        <TodoInput addTodo={addTodo} />
        <TodoList
          todos={todos}
          toggleComplete={toggleComplete}
          deleteTodo={deleteTodo}
        />
      </div>
    </div>
  );
};

export default App;
```

---

## **6. How It Works**

| Function           | Purpose                                     |
| ------------------ | ------------------------------------------- |
| `useState`         | Store todos and handle reactivity           |
| `useRef`           | Focus back on input after adding a task     |
| `useEffect`        | Save todos to localStorage whenever changed |
| `toggleComplete()` | Updates boolean state                       |
| `deleteTodo()`     | Filters out unwanted task                   |

---

## **7. Why This Project Is Important**

| Concept               | Real-World Relevance                                          |
| --------------------- | ------------------------------------------------------------- |
| Component Composition | Large apps are just combinations of small reusable components |
| State & Props Flow    | Forms → Parent → Child                                        |
| Hooks in Action       | `useState`, `useEffect`, `useRef` integrated                  |
| Persistent State      | Mimics real-world applications                                |
| Dynamic UI            | Rendering lists and conditionally styling items               |

---

## **8. Optional Enhancements**

| Feature                           | Concept                            |
| --------------------------------- | ---------------------------------- |
| Edit Todo                         | Controlled inputs + conditional UI |
| Filter (All / Active / Completed) | Derived state logic                |
| Dark Mode                         | useContext or global state         |
| API Sync                          | useEffect for CRUD calls           |

---

## **9. Key Takeaways**

* You just combined **three hooks** (`useState`, `useEffect`, `useRef`) into a functional app.
* State drives UI. Every user action → triggers state update → triggers render.
* Component hierarchy and props flow define the architecture.
* Local persistence teaches **data lifecycle** in React.

---

# **Project 3: Meals API Project 🍽️**

*(Focus: API integration + React hooks + real-world UI design)*

---

## **1. Objective**

We’ll build a **Meals Explorer** app that:

* Fetches meal data from an **external API (TheMealDB)**
* Displays meal cards (image, title, category)
* Includes a **search bar** to filter meals dynamically
* Uses loading + error handling logic

---

## **2. Concepts Covered**

| Concept               | Description                                  |
| --------------------- | -------------------------------------------- |
| useEffect             | Fetch API data on component mount            |
| useState              | Store data, loading, error, and search query |
| Controlled Inputs     | Manage search bar                            |
| Conditional Rendering | Handle empty, loading, or error states       |
| Dynamic Lists         | Map through API data                         |
| Tailwind              | Layout + responsive design                   |

---

## **3. API Used**

We’ll use the free **MealDB API**:
**`https://www.themealdb.com/api/json/v1/1/search.php?s=`**

* Example:

  * `s=chicken` → fetches all chicken meals.
  * `s=` (empty) → fetches all meals.

---

## **4. Folder Structure**

```
meals-api-project/
 ┣ src/
 ┃ ┣ components/
 ┃ ┃ ┣ SearchBar.jsx
 ┃ ┃ ┣ MealCard.jsx
 ┃ ┃ ┗ MealsList.jsx
 ┃ ┗ App.jsx
 ┣ index.js
 ┣ tailwind.css
```

---

## **5. Step-by-Step Logic (What, Why, How)**

| Step | Task                                   | Why                                       |
| ---- | -------------------------------------- | ----------------------------------------- |
| 1    | Create `search` state                  | For controlled input                      |
| 2    | Fetch meals from API in `useEffect`    | Load on mount and whenever search changes |
| 3    | Store data in `meals` state            | For dynamic rendering                     |
| 4    | Add `loading` + `error` handling       | Better UX                                 |
| 5    | Render cards using map                 | Dynamic list UI                           |
| 6    | Use Tailwind for clean responsive grid | Visual clarity                            |

---

## **6. Code Implementation**

### **`SearchBar.jsx`**

```jsx
import React from "react";

const SearchBar = ({ search, setSearch }) => {
  return (
    <div className="mb-6 flex justify-center">
      <input
        type="text"
        placeholder="Search meals..."
        value={search}
        onChange={(e) => setSearch(e.target.value)}
        className="w-full max-w-md border border-gray-300 rounded-lg px-4 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
      />
    </div>
  );
};

export default SearchBar;
```

---

### **`MealCard.jsx`**

```jsx
import React from "react";

const MealCard = ({ meal }) => {
  return (
    <div className="bg-white rounded-xl shadow-md overflow-hidden hover:shadow-lg transition">
      <img
        src={meal.strMealThumb}
        alt={meal.strMeal}
        className="w-full h-48 object-cover"
      />
      <div className="p-4">
        <h3 className="text-lg font-semibold text-gray-800">{meal.strMeal}</h3>
        <p className="text-sm text-gray-500">{meal.strCategory}</p>
      </div>
    </div>
  );
};

export default MealCard;
```

---

### **`MealsList.jsx`**

```jsx
import React from "react";
import MealCard from "./MealCard";

const MealsList = ({ meals, loading, error }) => {
  if (loading)
    return <p className="text-center text-gray-500 mt-10">Loading meals...</p>;

  if (error)
    return <p className="text-center text-red-500 mt-10">Failed to fetch meals.</p>;

  if (!meals || meals.length === 0)
    return <p className="text-center text-gray-400 mt-10">No meals found.</p>;

  return (
    <div className="grid gap-6 sm:grid-cols-2 lg:grid-cols-3">
      {meals.map((meal) => (
        <MealCard key={meal.idMeal} meal={meal} />
      ))}
    </div>
  );
};

export default MealsList;
```

---

### **`App.jsx`**

```jsx
import React, { useEffect, useState } from "react";
import SearchBar from "./components/SearchBar";
import MealsList from "./components/MealsList";

const App = () => {
  const [search, setSearch] = useState("");
  const [meals, setMeals] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  const fetchMeals = async () => {
    try {
      setLoading(true);
      setError(null);
      const res = await fetch(
        `https://www.themealdb.com/api/json/v1/1/search.php?s=${search}`
      );
      const data = await res.json();
      setMeals(data.meals || []);
    } catch (err) {
      setError("Failed to fetch meals.");
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchMeals();
  }, [search]);

  return (
    <div className="min-h-screen bg-gray-50 py-10 px-4">
      <h1 className="text-3xl font-bold text-center text-blue-600 mb-6">
        Meals Explorer
      </h1>
      <SearchBar search={search} setSearch={setSearch} />
      <MealsList meals={meals} loading={loading} error={error} />
    </div>
  );
};

export default App;
```

---

## **7. Understanding the Logic**

1. **`useEffect` + `fetch`** → handles API requests whenever `search` changes.
2. **`useState`** → manages multiple states:

   * `meals`: API data
   * `loading`: loader flag
   * `error`: catch fetch failure
   * `search`: controlled input
3. **`SearchBar`** → updates `search`, triggers re-render → `useEffect` runs again → new API call.
4. **`MealsList`** → handles display logic and conditions.
5. **Tailwind** → gives layout clarity (grid, shadows, spacing).

---

## **8. Why This Project Matters**

| Concept               | Real-World Application                   |
| --------------------- | ---------------------------------------- |
| `useEffect`           | Fetching data from REST APIs             |
| `useState`            | Handling loading, error, and data states |
| Controlled Inputs     | Search, filtering, and form handling     |
| Reusable Components   | Scalable UI design                       |
| Conditional Rendering | Managing UX feedback gracefully          |

---

## **9. Optional Enhancements**

| Feature              | Concept                                    |
| -------------------- | ------------------------------------------ |
| “Load More” Button   | Pagination logic                           |
| “Favorite Meals”     | State persistence with localStorage        |
| “Meal Details Modal” | Props drilling + portals                   |
| Skeleton Loader      | Preloading UX                              |
| Debounce Search      | `useRef` + controlled timing for API calls |

---

## **10. Key Takeaways**

* You’ve learned **API fetching**, a crucial skill for any React developer.
* Handled **UI states (loading/error/empty)** properly.
* Learned how **controlled inputs + useEffect** work together to create interactive apps.
* Practiced **component architecture** and **clean UI building** with Tailwind.

---

# **Project 4: Calculator (React + TailwindCSS)**

---

## **1. What Are We Building**

A **simple yet smart calculator** that performs basic arithmetic:
Addition, Subtraction, Multiplication, Division, and Clear.

We’ll focus on:

* Component structure
* State management using `useState`
* Event handling
* Conditional rendering
* Clean UI using **TailwindCSS**

---

## **2. Problem Understanding**

We want to simulate how a real calculator works.

**User Expectations:**

* Click numbers to input values.
* Click an operator (+, −, ×, ÷).
* Press `=` to compute.
* Press `C` to reset.

---

## **3. Breaking It Down**

We’ll have:

1. **Display Area** → shows current input/result.
2. **Buttons Grid** → 0–9, operators, clear, and equal.
3. **Logic Handler** → performs calculation based on inputs.

---

## **4. Key React Concepts Used**

| Concept               | Why Used                | How                                  |
| --------------------- | ----------------------- | ------------------------------------ |
| `useState`            | Store input and result  | Holds the current display string     |
| Event Handling        | Handle button clicks    | `onClick={() => handleClick(value)}` |
| Conditional Rendering | Control what’s shown    | Reset or show new result             |
| Props (optional)      | To pass values to child | If we modularize buttons             |

---

## **5. Thought Process**

We’ll store **everything typed (as string)**, and only when `=` is pressed, we’ll **evaluate** it.

**Example Flow:**

```
User clicks → "5" → "+"
User clicks → "3" → "="
We evaluate "5+3" → show 8
```

---

## **6. Folder Structure**

```
calculator/
├── src/
│   ├── App.jsx
│   ├── index.css
│   ├── components/
│   │   ├── Display.jsx
│   │   ├── Button.jsx
│   │   └── ButtonGrid.jsx
│   └── main.jsx
└── tailwind.config.js
```

---

## **7. Code Implementation**

### **App.jsx**

```jsx
import React, { useState } from "react";
import Display from "./components/Display";
import ButtonGrid from "./components/ButtonGrid";

export default function App() {
  const [input, setInput] = useState("");

  const handleClick = (value) => {
    if (value === "C") {
      setInput("");
    } else if (value === "=") {
      try {
        // eval() is fine for learning. In real apps, use a parser.
        setInput(eval(input).toString());
      } catch {
        setInput("Error");
      }
    } else {
      setInput(input + value);
    }
  };

  return (
    <div className="flex justify-center items-center h-screen bg-gray-100">
      <div className="bg-white p-6 rounded-2xl shadow-xl w-72">
        <Display input={input} />
        <ButtonGrid handleClick={handleClick} />
      </div>
    </div>
  );
}
```

---

### **Display.jsx**

```jsx
export default function Display({ input }) {
  return (
    <div className="bg-gray-200 rounded-xl text-right p-4 text-2xl font-mono mb-4 h-14 flex items-center justify-end">
      {input || "0"}
    </div>
  );
}
```

---

### **ButtonGrid.jsx**

```jsx
import Button from "./Button";

export default function ButtonGrid({ handleClick }) {
  const buttons = [
    "7", "8", "9", "/",
    "4", "5", "6", "*",
    "1", "2", "3", "-",
    "0", ".", "=", "+",
    "C"
  ];

  return (
    <div className="grid grid-cols-4 gap-3">
      {buttons.map((btn) => (
        <Button key={btn} value={btn} handleClick={handleClick} />
      ))}
    </div>
  );
}
```

---

### **Button.jsx**

```jsx
export default function Button({ value, handleClick }) {
  const colorClass =
    value === "C"
      ? "bg-red-400 hover:bg-red-500"
      : value === "="
      ? "bg-green-400 hover:bg-green-500"
      : "bg-gray-300 hover:bg-gray-400";

  return (
    <button
      onClick={() => handleClick(value)}
      className={`${colorClass} text-xl rounded-xl p-3 transition`}
    >
      {value}
    </button>
  );
}
```

---

## **8. Dry Run Example**

**Click Flow:**

1. Click `2` → `input = "2"`
2. Click `+` → `input = "2+"`
3. Click `3` → `input = "2+3"`
4. Click `=` → `eval("2+3") → 5`

Display shows: **5**

---

## **9. Time & Space Complexity**

| Operation      | Complexity                       |
| -------------- | -------------------------------- |
| Input Handling | O(1)                             |
| Calculation    | O(1) for simple ops              |
| UI Rendering   | O(n) where n = number of buttons |

---

## **10. Optimization**

* Avoid `eval()` in production (use math.js or manual parsing).
* Add keyboard input support.
* Add history of operations.

---

## **11. Reflection**

What we learned:

* Controlled components using `useState`.
* Handling dynamic user input.
* Component modularity (Display, Button, ButtonGrid).
* Tailwind for fast, clean design.

---

## **12. Next Step (Challenge)**

Upgrade this calculator:

* Add dark/light mode using `useEffect + Tailwind`.
* Add advanced operations (%, √, ^).
* Store last result in `useRef`.

---

# **Project 5: Color Toggler (Deep Conceptual Build)**

---

## **1. Understanding the Problem**

We want a small app that toggles the background color of the screen each time a button is clicked.
Example:

* Light → Dark
* Dark → Light

You see this same behavior in:

* System-wide **dark mode toggles**
* Editors like VS Code
* Apps like YouTube, Twitter, or GitHub

So, let’s simulate this with React — but our focus isn’t the UI; it’s **understanding the React concepts that make this work.**

---

## **2. What Problem React Solves Here**

If you were to build this in **plain JavaScript**, you’d:

* Select DOM elements with `document.querySelector`
* Manually change the `style.backgroundColor`
* Attach event listeners to buttons

That approach:

* Causes manual DOM manipulation (error-prone)
* Becomes hard to maintain for larger UIs
* Doesn’t automatically update dependent UI states

React solves this by introducing:

* **State-driven UI** — when data (state) changes, React re-renders automatically
* **Declarative logic** — you declare what UI should look like *for a given state*

---

## **3. Concept Mapping**

Let’s map which React concepts we’ll use and **why**:

| Concept                | Why Needed                       | Where It’s Used                      |
| ---------------------- | -------------------------------- | ------------------------------------ |
| `Component`            | To create reusable logic/UI unit | `App.jsx` is our main component      |
| `useState`             | To store current theme/color     | Track if we’re in Light or Dark mode |
| `Event Handling`       | To listen for user click         | Toggle button to switch theme        |
| Conditional Rendering  | To apply different styles        | Switch background dynamically        |
| `useEffect` (optional) | To remember user choice          | Save preference in localStorage      |
| Tailwind CSS           | To style UI quickly              | Add color and transitions            |

So, you see — even in a tiny project, **every React concept has a clear role**.

---

## **4. Thought Process Before Coding**

Let’s break down the logic in English before writing any code.

1. Create a state variable `isDarkMode` → default to `false`
2. Create a function `toggleMode()` → flips the value between true/false
3. Use conditional rendering:

   * if `isDarkMode === true` → apply dark styles
   * else → apply light styles
4. Render a button → when clicked, call `toggleMode`
5. (Optional) Store mode in `localStorage` so it persists even after refresh.

That’s your **data → UI → interaction** cycle in React.

---

## **5. Project Setup & Folder Structure**

```
color-toggler/
 ┣ src/
 ┃ ┣ components/
 ┃ ┃ ┗ ColorToggler.jsx
 ┃ ┣ App.jsx
 ┃ ┣ index.css
 ┃ ┗ main.jsx
 ┣ tailwind.config.js
 ┗ package.json
```

---

## **6. Implementation**

### **ColorToggler.jsx**

```jsx
import React, { useState, useEffect } from "react";

/**
 * Concept Focus:
 * - useState (state management)
 * - Conditional Rendering
 * - Event Handling
 * - useEffect (side effect for persistence)
 */

const ColorToggler = () => {
  // STEP 1: Define state (reactive variable)
  const [isDarkMode, setIsDarkMode] = useState(false);

  // STEP 2: Optional - load user preference
  useEffect(() => {
    const savedTheme = localStorage.getItem("theme");
    if (savedTheme === "dark") {
      setIsDarkMode(true);
    }
  }, []);

  // STEP 3: Whenever theme changes, store it
  useEffect(() => {
    localStorage.setItem("theme", isDarkMode ? "dark" : "light");
  }, [isDarkMode]);

  // STEP 4: Handler function
  const toggleMode = () => {
    setIsDarkMode((prev) => !prev); // toggle between true and false
  };

  // STEP 5: Conditional styling (Tailwind)
  const bgClass = isDarkMode ? "bg-gray-900 text-white" : "bg-gray-100 text-black";

  return (
    <div className={`h-screen flex flex-col items-center justify-center transition-all duration-500 ${bgClass}`}>
      <h1 className="text-4xl font-bold mb-6">
        {isDarkMode ? "Dark Mode 🌙" : "Light Mode ☀️"}
      </h1>

      <button
        onClick={toggleMode}
        className={`px-6 py-3 rounded-xl text-lg font-medium transition-all duration-300 shadow-md ${
          isDarkMode
            ? "bg-gray-200 text-black hover:bg-gray-300"
            : "bg-gray-800 text-white hover:bg-gray-700"
        }`}
      >
        Toggle Theme
      </button>
    </div>
  );
};

export default ColorToggler;
```

---

### **App.jsx**

```jsx
import React from "react";
import ColorToggler from "./components/ColorToggler";

function App() {
  return <ColorToggler />;
}

export default App;
```

---

## **7. Step-by-Step Logic Flow**

1. App loads → `isDarkMode = false` → renders Light theme
2. User clicks “Toggle Theme” → handler flips state
3. React re-renders → now `isDarkMode = true` → Dark theme applied
4. UI instantly updates (without DOM manipulation)
5. React’s Virtual DOM efficiently updates only what’s changed

---

## **8. Visual Output**

| Action                 | Screen                                            |
| ---------------------- | ------------------------------------------------- |
| Initial                | Light screen with ☀️ text                         |
| Click Toggle           | Instantly changes to dark background with 🌙 text |
| Refresh (after saving) | Restores previous theme from `localStorage`       |

---

## **9. Why These Hooks & Concepts Are Used**

| Concept               | Why It’s the Right Choice                        |
| --------------------- | ------------------------------------------------ |
| `useState`            | We need UI to react to internal data changes     |
| `useEffect`           | We need to perform side effects (save/load data) |
| Conditional rendering | Different output based on state                  |
| Event handling        | Respond to user clicks                           |

Whenever you find yourself thinking:

> “I want my UI to change when something in memory changes,”
> that’s your hint — **useState** is needed.

And if you think:

> “I need to do something *after* my component renders or updates,”
> then **useEffect** comes in.

---

## **10. Optimization Ideas**

* Add multiple themes (e.g., blue, green, purple)
* Add animation on color change using Tailwind’s `transition`
* Add a small toggle switch (UI) instead of a button
* Integrate system theme detection using:

  ```js
  window.matchMedia("(prefers-color-scheme: dark)").matches
  ```

---

## **11. Learning Takeaways**

* **React is declarative:** You tell React what UI *should* look like for a given state.
* **State drives everything:** The UI is always a reflection of the current state.
* **Re-rendering is automatic:** React efficiently updates the UI when state changes.
* **Hooks connect logic with UI:** You can have memory (`useState`), side effects (`useEffect`), and more — all inside functional components.

---

# **Project 6: Search Icon Project (React + Tailwind)**

---

## **1. What Are We Building**

We’ll build a **search bar toggle UI** — when you click a search icon, it expands to show an input box; when you click again or blur, it collapses.

Example:

* Think of the small magnifying glass icon on YouTube, Gmail, or Chrome.
* Initially, you just see a search icon 🔍.
* On click → it smoothly expands into a search bar with an input field.

---

## **2. What Problem Are We Solving**

Modern UIs prioritize **clean, minimal layouts**.
So, rather than showing a search input all the time, we keep it **hidden** until needed.

This helps us understand:

* How to show/hide components dynamically.
* How to control an input field in React.
* How state manages visual behavior and user interaction.

---

## **3. Concept Mapping**

Let’s identify the **React concepts** involved and **why** we need them:

| Concept               | Why Needed                                   | Example                                       |
| --------------------- | -------------------------------------------- | --------------------------------------------- |
| `useState`            | To track if the search box is open or closed | `const [isOpen, setIsOpen] = useState(false)` |
| Event Handling        | Listen for icon click / blur                 | `onClick`, `onBlur`                           |
| Conditional Rendering | Toggle between icon and input field          | `{isOpen ? <input /> : <Icon />}`             |
| Controlled Component  | Sync input text with React state             | `value={query}`                               |
| TailwindCSS           | For animation, transition, and styling       | Smooth expand/shrink effect                   |

---

## **4. Thought Process Before Coding**

When you start building **anything** in React, you first describe it like this:

| Step | Behavior                                   | What React Needs                 |
| ---- | ------------------------------------------ | -------------------------------- |
| 1    | Show search icon initially                 | Default state = closed           |
| 2    | When clicked → show search input           | Update state → open              |
| 3    | Input box should capture user text         | Controlled input with `useState` |
| 4    | Optional: Hide input when user clicks away | Use `onBlur` or close button     |
| 5    | Animate transitions for smooth UX          | Tailwind classes                 |

---

## **5. Folder Setup**

```
search-icon-app/
 ┣ src/
 ┃ ┣ components/
 ┃ ┃ ┗ SearchBar.jsx
 ┃ ┣ App.jsx
 ┃ ┗ main.jsx
 ┣ tailwind.config.js
 ┗ package.json
```

---

## **6. Implementation**

### **SearchBar.jsx**

```jsx
import React, { useState } from "react";

/**
 * Concepts used:
 * - useState (UI + Input State)
 * - Conditional Rendering
 * - Event Handling
 * - Controlled Components
 * - Tailwind Transitions
 */

const SearchBar = () => {
  // 1. Track whether search bar is open or not
  const [isOpen, setIsOpen] = useState(false);

  // 2. Track user input text
  const [query, setQuery] = useState("");

  // 3. Handler for toggling
  const handleToggle = () => {
    setIsOpen((prev) => !prev);
  };

  // 4. Input change handler
  const handleInputChange = (e) => {
    setQuery(e.target.value);
  };

  // 5. Optional: handle blur (click outside)
  const handleBlur = () => {
    if (query.trim() === "") setIsOpen(false);
  };

  return (
    <div className="flex justify-center items-center h-screen bg-gray-100">
      {/* Container with shadow and smooth transition */}
      <div
        className={`flex items-center bg-white border border-gray-300 rounded-full shadow-md transition-all duration-300 ${
          isOpen ? "w-72 px-4" : "w-12 px-2"
        }`}
      >
        {/* Conditional Rendering - Input visible only if isOpen true */}
        {isOpen && (
          <input
            type="text"
            value={query}
            onChange={handleInputChange}
            onBlur={handleBlur}
            placeholder="Search..."
            className="flex-1 px-2 py-2 outline-none text-gray-700"
          />
        )}

        {/* Search Icon - Always visible */}
        <button
          onClick={handleToggle}
          className="p-2 text-gray-600 hover:text-gray-900 transition"
        >
          🔍
        </button>
      </div>
    </div>
  );
};

export default SearchBar;
```

---

### **App.jsx**

```jsx
import React from "react";
import SearchBar from "./components/SearchBar";

function App() {
  return <SearchBar />;
}

export default App;
```

---

## **7. Step-by-Step Logic Flow**

| Step | Action              | State                      | Result                            |
| ---- | ------------------- | -------------------------- | --------------------------------- |
| 1    | App loads           | `isOpen = false`           | Only search icon visible          |
| 2    | User clicks 🔍      | `isOpen = true`            | Search bar expands, input appears |
| 3    | User types “React”  | `query = "React"`          | Input text synced with React      |
| 4    | User clicks outside | `onBlur` → closes if empty | Collapses back to icon            |
| 5    | If text entered     | Stays open                 | UX-friendly behavior              |

---

## **8. Why These Hooks & Concepts Were Chosen**

| Need                                          | Solution                 | Concept                       |
| --------------------------------------------- | ------------------------ | ----------------------------- |
| We need to remember if the search bar is open | Store in component state | `useState(isOpen)`            |
| We need to track what the user types          | Controlled input         | `useState(query)`             |
| We need to show/hide elements dynamically     | Conditional rendering    | `{isOpen && <input />}`       |
| We need smooth transitions                    | Tailwind transitions     | `transition-all duration-300` |
| We need to handle user interactions           | Event listeners          | `onClick`, `onBlur`           |

So every concept is a *logical answer* to a real UI requirement — that’s how React is meant to be used.

---

## **9. Tailwind Breakdown**

| Behavior            | Tailwind Class                     |
| ------------------- | ---------------------------------- |
| Rounded search box  | `rounded-full`                     |
| Expand animation    | `transition-all duration-300`      |
| Shadow              | `shadow-md`                        |
| Smooth width change | dynamic class based on state       |
| Clean layout        | `flex items-center justify-center` |

---

## **10. What’s Happening Under the Hood**

* React uses **Virtual DOM** to track differences between the “open” and “closed” versions of the UI.
* When you call `setIsOpen`, React re-renders the component.
* It efficiently updates only the changed part — adding/removing the `<input>` element.
* Tailwind transitions animate the visual changes.

---

## **11. Common Mistakes to Avoid**

1. Forgetting to control the input (always bind `value` and `onChange`).
2. Using regular variables instead of `useState` (no re-render will occur).
3. Not using `onBlur` properly — can cause input to instantly disappear when clicking inside.
4. Mixing inline styles and Tailwind unnecessarily — always prefer Tailwind for consistency.

---

## **12. Real-World Extensions**

| Feature                                       | Concept Learned              |
| --------------------------------------------- | ---------------------------- |
| Implement live filtering (e.g., product list) | useState + Array.filter      |
| Add debounce (delay typing)                   | useEffect + setTimeout       |
| Animate icon rotation                         | Tailwind + Conditional class |
| Integrate with API                            | useEffect + fetch            |

---

## **13. Learning Takeaways**

* React apps are built by **mapping UI changes to state**.
* Every **UI behavior = some state variable + conditional rendering**.
* **Controlled components** are core to every form or input you’ll ever build.
* Tailwind helps you visualize **state changes → UI transitions** clearly.

---

## **14. Challenge Exercise (Highly Recommended)**

Enhance this same app:

1. Add a **clear (✖)** button when the input is open and not empty.
2. When typing something, log it to the console (simulate API search).
3. Add `useEffect` to debounce user input (wait 500ms before logging).

---

# **Project 07 — Testimonials Component**

## **1. Project Overview**

We’ll build a **Testimonials Component** where users can:

* View client feedback (name, role, image, message)
* Navigate between testimonials using buttons or auto-slide (optional)
* Understand how to structure reusable UI blocks dynamically

We’ll focus on **Component composition**, **Dynamic rendering**, and **State management** with `useState`.

---

## **2. Problem**

When building a product page, you often need to **display user feedback or reviews**.
Instead of hardcoding one testimonial, you want:

* Reusable and dynamic rendering
* Next/Previous navigation
* Visually appealing layout

---

## **3. Concepts Used**

| Concept                   | Why We Use It                                    |
| ------------------------- | ------------------------------------------------ |
| **Component Reusability** | Each testimonial can be a reusable component     |
| **Props**                 | To pass testimonial data (name, message, image)  |
| **State (`useState`)**    | To track the current testimonial being displayed |
| **Conditional Rendering** | To show active testimonial                       |
| **TailwindCSS**           | For clean and quick styling                      |
| **Array Mapping**         | To dynamically generate testimonials             |
| **Optional:** `useEffect` | To auto-slide testimonials after some time       |

---

## **4. Folder & File Setup**

```
src/
 ├── components/
 │    ├── TestimonialCard.jsx
 │    ├── TestimonialsList.jsx
 │
 ├── App.jsx
 ├── App.css
 ├── main.jsx
```

---

## **5. Step-by-Step Breakdown**

### **Step 1: Define Data**

We’ll keep testimonials as a simple array of objects.

```jsx
// src/components/TestimonialsList.jsx
import { useState } from "react";
import TestimonialCard from "./TestimonialCard";

const testimonialsData = [
  {
    id: 1,
    name: "Tanish",
    role: "Frontend Developer",
    feedback: "React has completely changed how I think about UI development!",
    image: "https://i.pravatar.cc/100?img=1",
  },
  {
    id: 2,
    name: "Aarav",
    role: "UI/UX Designer",
    feedback: "Tailwind CSS makes styling so effortless and fun.",
    image: "https://i.pravatar.cc/100?img=2",
  },
  {
    id: 3,
    name: "Neha",
    role: "Full Stack Engineer",
    feedback: "Hooks made me understand the logic behind functional components deeply!",
    image: "https://i.pravatar.cc/100?img=3",
  },
];

export default function TestimonialsList() {
  const [currentIndex, setCurrentIndex] = useState(0);

  const handleNext = () => {
    setCurrentIndex((prev) => (prev + 1) % testimonialsData.length);
  };

  const handlePrev = () => {
    setCurrentIndex((prev) =>
      prev === 0 ? testimonialsData.length - 1 : prev - 1
    );
  };

  return (
    <div className="flex flex-col items-center justify-center min-h-screen bg-gray-50 p-6">
      <h1 className="text-3xl font-bold mb-8 text-gray-800">Testimonials</h1>

      <TestimonialCard data={testimonialsData[currentIndex]} />

      <div className="flex gap-4 mt-6">
        <button
          onClick={handlePrev}
          className="bg-gray-200 hover:bg-gray-300 px-4 py-2 rounded-lg"
        >
          Prev
        </button>
        <button
          onClick={handleNext}
          className="bg-blue-600 text-white hover:bg-blue-700 px-4 py-2 rounded-lg"
        >
          Next
        </button>
      </div>
    </div>
  );
}
```

---

### **Step 2: Create TestimonialCard Component**

```jsx
// src/components/TestimonialCard.jsx
export default function TestimonialCard({ data }) {
  return (
    <div className="bg-white p-8 rounded-2xl shadow-lg max-w-md text-center transition-all duration-300">
      <img
        src={data.image}
        alt={data.name}
        className="w-20 h-20 rounded-full mx-auto mb-4 border-4 border-blue-500"
      />
      <h2 className="text-xl font-semibold">{data.name}</h2>
      <p className="text-sm text-gray-500 mb-3">{data.role}</p>
      <p className="text-gray-700 italic">“{data.feedback}”</p>
    </div>
  );
}
```

---

### **Step 3: Integrate in App.jsx**

```jsx
// src/App.jsx
import TestimonialsList from "./components/TestimonialsList";

export default function App() {
  return (
    <div>
      <TestimonialsList />
    </div>
  );
}
```

---

## **6. Logic Flow Explanation**

1. **State Management (`useState`)**

   * We track which testimonial is currently visible with `currentIndex`.

2. **Event Handlers**

   * `handleNext` → Moves to the next testimonial (loops using modulo `%`).
   * `handlePrev` → Moves back, wraps around when index hits 0.

3. **Props Flow**

   * Each testimonial’s data is passed from `TestimonialsList` → `TestimonialCard`.

4. **Conditional Rendering**

   * Only one testimonial (based on `currentIndex`) is visible at a time.

5. **Reusability**

   * If tomorrow you fetch testimonials via an API, you just replace `testimonialsData` with fetched data — no structural change needed.

---

## **7. Optional: Auto Slide with useEffect**

If you want auto sliding every few seconds:

```jsx
import { useEffect } from "react";

useEffect(() => {
  const timer = setInterval(() => {
    handleNext();
  }, 4000);
  return () => clearInterval(timer);
}, []);
```

---

## **8. Why This Approach**

| Challenge           | Why Our Approach Solves It               |
| ------------------- | ---------------------------------------- |
| Manual DOM updates  | React manages re-rendering automatically |
| Repeated HTML       | Dynamic rendering using `.map()`         |
| Managing UI updates | `useState` for reactive changes          |
| UI Consistency      | Tailwind utility classes                 |

---

## **9. Key Learnings**

* **Props & State** integration across components
* **Component hierarchy** and **data flow**
* **Clean Tailwind styling** and layout
* Optional **automation** with `useEffect`
* Logic separation — small focused components (`Card`, `List`)

---

## **10. Reflection**

You just built a **production-style Testimonials Section** with:

* Dynamic state
* Component-based structure
* Styled UI
* Extendable logic (e.g., auto-slide, API fetching)

This is a **mini milestone** because now you can dynamically render **real data** in a structured, reusable way.

---

# **How Data Passed Between Components (Props Flow)**

Let’s visualize the relationship:

```
App.jsx
 └── TestimonialsList.jsx   (Parent)
        └── TestimonialCard.jsx   (Child)
```

This is a **Parent → Child relationship**.
Now, React data flow is **unidirectional (one way)** — meaning **data can only flow downward** (from parent to child).

---

## **1. Step-by-Step Explanation**

### **(a) Step 1: Data exists in parent**

In `TestimonialsList.jsx`, we created an array of testimonial objects:

```jsx
const testimonialsData = [
  {
    id: 1,
    name: "Tanish",
    role: "Frontend Developer",
    feedback: "React has completely changed how I think about UI development!",
    image: "https://i.pravatar.cc/100?img=1",
  },
  // ...
];
```

This array is only available **inside this component** because it’s declared there.
So, we must somehow **send** one testimonial object to the `TestimonialCard` to display it.

---

### **(b) Step 2: Select which testimonial to show**

We use state to track **which one** to display:

```jsx
const [currentIndex, setCurrentIndex] = useState(0);
```

Then we extract one testimonial object based on that index:

```jsx
const currentTestimonial = testimonialsData[currentIndex];
```

---

### **(c) Step 3: Pass that object as a prop**

When we render the child component:

```jsx
<TestimonialCard data={currentTestimonial} />
```

Here:

* `data` is the **prop name** (you can name it anything)
* `currentTestimonial` is the **value** (the selected object)

React internally passes that value as a property to the child component.

---

### **(d) Step 4: Child receives it as a function parameter**

In `TestimonialCard.jsx` we define:

```jsx
export default function TestimonialCard({ data }) {
  // now you can access data.name, data.role, etc.
}
```

Here `{ data }` is just **JavaScript object destructuring**.
If you didn’t use destructuring, it would look like this:

```jsx
export default function TestimonialCard(props) {
  return <h2>{props.data.name}</h2>;
}
```

But destructuring makes it cleaner:

```jsx
export default function TestimonialCard({ data }) {
  return <h2>{data.name}</h2>;
}
```

---

### **(e) Step 5: Child uses the data**

Now inside the child component, you can use `data` to render UI dynamically:

```jsx
<img src={data.image} alt={data.name} />
<h2>{data.name}</h2>
<p>{data.role}</p>
<p>{data.feedback}</p>
```

Each time the **parent’s state changes** (like when you click “Next” or “Prev”),
`currentIndex` updates → new object is passed → React **re-renders the child** with updated data.

---

## **2. Concept Visualization**

Let’s visualize data flow in a simple diagram:

```
TestimonialsList (Parent)
    |
    |-- currentIndex = 0
    |-- currentData = testimonialsData[0]
    |
    ↓
TestimonialCard (Child)
    receives → props.data = currentData
```

When you click “Next”:

```
setCurrentIndex(1)
→ React re-renders TestimonialsList
→ currentData = testimonialsData[1]
→ passes new data down to TestimonialCard
→ TestimonialCard re-renders with new person info
```

---

## **3. Real Code Link (Simplified)**

```jsx
// Parent
export default function TestimonialsList() {
  const [index, setIndex] = useState(0);
  const data = [
    { name: "Tanish", role: "Dev" },
    { name: "Aarav", role: "Designer" },
  ];
  return <TestimonialCard data={data[index]} />;
}

// Child
export default function TestimonialCard({ data }) {
  return (
    <div>
      <h2>{data.name}</h2>
      <p>{data.role}</p>
    </div>
  );
}
```

---

## **4. Why We Do It This Way**

| Problem                                       | React Solution                                  |
| --------------------------------------------- | ----------------------------------------------- |
| We want to reuse UI for multiple testimonials | Make one reusable component (`TestimonialCard`) |
| We want to change which testimonial shows     | Manage state (`useState`) in parent             |
| We want parent to send selected data to child | Pass via props                                  |
| We want automatic re-render when data changes | React does it based on state change             |

---

## **5. Bonus: Same Folder Doesn’t Matter**

Even though both files are in the same folder (`components/`),
**what matters is how you import and render**, not their physical location.

React’s structure rule:

* Components communicate through **props and state**, not file hierarchy.
* Import path (like `import TestimonialCard from "./TestimonialCard"`) just tells React **where the file is located**.

---

## **6. Summary**

| Step | What Happens                        | Where                          |
| ---- | ----------------------------------- | ------------------------------ |
| 1    | Data array created                  | Parent (TestimonialsList)      |
| 2    | Current index managed by `useState` | Parent                         |
| 3    | Selected testimonial passed as prop | Parent → Child                 |
| 4    | Child receives via `({ data })`     | Child                          |
| 5    | Renders data dynamically            | Child UI updates automatically |

---

# **Project 08 — Accordion Component**

---

## **1. Project Overview**

We’ll build a **fully functional Accordion** — the kind you see in FAQ pages, dropdown menus, and dashboards.

Example behavior:

* Clicking on a question expands its answer.
* Clicking again hides it.
* Only one item open at a time (optional).
* Smooth animations using Tailwind.

---

## **2. Problem**

When designing a UI like FAQ, we need to **show and hide** sections dynamically based on user interaction.

Without React, this needs a lot of **manual DOM manipulation (querySelector, classList toggles)**.
React simplifies this by allowing **reactive rendering** using **state**.

---

## **3. Concepts Used**

| Concept                        | Why We Use It                                  |
| ------------------------------ | ---------------------------------------------- |
| **Components**                 | Each accordion item is reusable                |
| **Props**                      | To pass data (title and content)               |
| **useState**                   | To toggle open/close state                     |
| **Conditional Rendering**      | To show or hide content                        |
| **Array Mapping**              | To render multiple accordion items dynamically |
| **TailwindCSS**                | For instant responsive design                  |
| **Parent-Child Communication** | To control which accordion is open             |

---

## **4. Folder & File Setup**

```
src/
 ├── components/
 │    ├── Accordion.jsx
 │    ├── AccordionItem.jsx
 │
 ├── App.jsx
 ├── index.css
 ├── main.jsx
```

---

## **5. Step-by-Step Breakdown**

### **Step 1: Define Data and Logic (Parent Component)**

```jsx
// src/components/Accordion.jsx
import { useState } from "react";
import AccordionItem from "./AccordionItem";

const accordionData = [
  {
    id: 1,
    question: "What is React?",
    answer:
      "React is a JavaScript library for building user interfaces. It uses a component-based architecture.",
  },
  {
    id: 2,
    question: "What is a Hook in React?",
    answer:
      "Hooks are special functions that let you use React features like state and lifecycle in functional components.",
  },
  {
    id: 3,
    question: "What is Tailwind CSS?",
    answer:
      "Tailwind is a utility-first CSS framework that lets you design directly in your HTML with pre-defined classes.",
  },
];

export default function Accordion() {
  // which accordion is open
  const [openId, setOpenId] = useState(null);

  const toggleAccordion = (id) => {
    setOpenId(openId === id ? null : id); // collapse if already open
  };

  return (
    <div className="flex flex-col items-center min-h-screen bg-gray-50 py-10">
      <h1 className="text-3xl font-bold mb-8">FAQ - Accordion Example</h1>
      <div className="w-full max-w-lg bg-white rounded-xl shadow-md divide-y divide-gray-200">
        {accordionData.map((item) => (
          <AccordionItem
            key={item.id}
            data={item}
            isOpen={openId === item.id}
            toggle={() => toggleAccordion(item.id)}
          />
        ))}
      </div>
    </div>
  );
}
```

---

### **Step 2: Build the Accordion Item Component**

```jsx
// src/components/AccordionItem.jsx
export default function AccordionItem({ data, isOpen, toggle }) {
  return (
    <div>
      {/* Header */}
      <button
        onClick={toggle}
        className="w-full flex justify-between items-center px-5 py-4 text-left text-lg font-medium text-gray-800 hover:bg-gray-100 focus:outline-none"
      >
        <span>{data.question}</span>
        <span className="text-gray-500">{isOpen ? "-" : "+"}</span>
      </button>

      {/* Content (conditionally rendered) */}
      {isOpen && (
        <div className="px-5 pb-4 text-gray-600 transition-all duration-300">
          {data.answer}
        </div>
      )}
    </div>
  );
}
```

---

### **Step 3: Connect in App.jsx**

```jsx
// src/App.jsx
import Accordion from "./components/Accordion";

export default function App() {
  return (
    <div>
      <Accordion />
    </div>
  );
}
```

---

## **6. Logic Flow Explanation**

### **Parent (Accordion.jsx)**

* Holds the full **data array**.
* Tracks the `openId` — which item is currently open.
* Passes 3 props to each `AccordionItem`:

  1. `data` → question + answer object
  2. `isOpen` → whether it’s open or closed
  3. `toggle()` → function to open/close it

### **Child (AccordionItem.jsx)**

* Receives data and shows/hides content based on `isOpen`.
* On click, calls `toggle()` which triggers parent’s state change.
* When `openId` changes in parent → React re-renders all items → only one stays open.

---

## **7. Step-by-Step Data Flow Visualization**

```
Accordion (Parent)
   |
   |-- openId = 2
   |-- toggleAccordion(id)
   |
   ↓
AccordionItem (Child)
   - data = { question, answer }
   - isOpen = openId === data.id
   - toggle = triggers parent update
```

---

## **8. Why We Use These Concepts Here**

| Concept                   | Role                                               |
| ------------------------- | -------------------------------------------------- |
| **useState**              | Track which accordion item is open                 |
| **Props**                 | Pass data and state control between parent & child |
| **Conditional Rendering** | Show/hide content                                  |
| **Reusable Components**   | Use one `AccordionItem` for all questions          |
| **TailwindCSS**           | Styling + smooth UI transitions                    |

---

## **9. Enhancement Ideas**

Once you understand the base, you can extend:

* Add **transition animations** using Tailwind’s `transition-max-height`.
* Add **multiple open support** (change `openId` to an array of open IDs).
* Load accordion data from an **API** instead of hardcoding.

---

## **10. Key Learnings**

* **State control from parent component** (centralized logic)
* **Prop drilling** — passing data + control down
* **Re-render cycle** based on state updates
* **Component composition pattern**
* **Smooth, maintainable UI using Tailwind**

---

## **11. Reflection**

You now know how to:

* Dynamically **render multiple reusable components** using `.map()`.
* Use **state and props** together for UI behavior control.
* Keep UI clean and scalable.

This pattern — **parent manages logic, child handles UI** — is core to how React scales in large apps.

---

# **Project 09 — Form Validation**

---

## **1. Project Overview**

We’ll build a **user registration form** that:

* Takes user input (name, email, password)
* Validates fields (required, format, password strength)
* Shows live feedback (errors update as user types)
* Uses React Hooks (`useState`, `useEffect`, optionally `useRef`)
* Styled cleanly using TailwindCSS

---

## **2. Problem**

Forms are everywhere — login, signup, checkout, contact, etc.
Without React, validation logic is messy — lots of manual checks and direct DOM updates.
With React:

* Input values are **tracked in state**
* Validation logic is **reactive**
* Errors update automatically as state changes

---

## **3. Concepts Used**

| Concept                   | Why We Use It                            |
| ------------------------- | ---------------------------------------- |
| **Controlled Components** | Sync input fields with React state       |
| **useState**              | Store form data and validation errors    |
| **Event Handling**        | Handle input changes and form submission |
| **Conditional Rendering** | Show error messages dynamically          |
| **useEffect (optional)**  | For live validation or side effects      |
| **TailwindCSS**           | For instant responsive UI styling        |
| **Form Validation Logic** | Handle required fields and regex checks  |

---

## **4. Folder & File Setup**

```
src/
 ├── components/
 │    ├── FormValidation.jsx
 │
 ├── App.jsx
 ├── index.css
 ├── main.jsx
```

---

## **5. Step-by-Step Implementation**

### **Step 1: Create the Form Component**

```jsx
// src/components/FormValidation.jsx
import { useState } from "react";

export default function FormValidation() {
  const [formData, setFormData] = useState({
    name: "",
    email: "",
    password: "",
  });

  const [errors, setErrors] = useState({});

  // handle user typing
  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData({ ...formData, [name]: value });
  };

  // simple validation
  const validate = () => {
    const newErrors = {};

    if (!formData.name.trim()) {
      newErrors.name = "Name is required";
    }

    if (!formData.email.trim()) {
      newErrors.email = "Email is required";
    } else if (!/\S+@\S+\.\S+/.test(formData.email)) {
      newErrors.email = "Email format is invalid";
    }

    if (!formData.password.trim()) {
      newErrors.password = "Password is required";
    } else if (formData.password.length < 6) {
      newErrors.password = "Password must be at least 6 characters";
    }

    return newErrors;
  };

  // handle form submit
  const handleSubmit = (e) => {
    e.preventDefault();

    const validationErrors = validate();
    setErrors(validationErrors);

    if (Object.keys(validationErrors).length === 0) {
      alert("Form submitted successfully!");
      console.log("Form Data:", formData);

      // reset form
      setFormData({ name: "", email: "", password: "" });
    }
  };

  return (
    <div className="flex justify-center items-center min-h-screen bg-gray-50">
      <form
        onSubmit={handleSubmit}
        className="bg-white shadow-md rounded-xl px-8 py-8 w-full max-w-md"
      >
        <h2 className="text-2xl font-semibold mb-6 text-center text-gray-800">
          Registration Form
        </h2>

        {/* Name */}
        <div className="mb-4">
          <label className="block text-gray-700 mb-2">Name</label>
          <input
            type="text"
            name="name"
            value={formData.name}
            onChange={handleChange}
            className={`w-full border ${
              errors.name ? "border-red-500" : "border-gray-300"
            } rounded-lg px-3 py-2 focus:outline-none`}
          />
          {errors.name && (
            <p className="text-red-500 text-sm mt-1">{errors.name}</p>
          )}
        </div>

        {/* Email */}
        <div className="mb-4">
          <label className="block text-gray-700 mb-2">Email</label>
          <input
            type="email"
            name="email"
            value={formData.email}
            onChange={handleChange}
            className={`w-full border ${
              errors.email ? "border-red-500" : "border-gray-300"
            } rounded-lg px-3 py-2 focus:outline-none`}
          />
          {errors.email && (
            <p className="text-red-500 text-sm mt-1">{errors.email}</p>
          )}
        </div>

        {/* Password */}
        <div className="mb-4">
          <label className="block text-gray-700 mb-2">Password</label>
          <input
            type="password"
            name="password"
            value={formData.password}
            onChange={handleChange}
            className={`w-full border ${
              errors.password ? "border-red-500" : "border-gray-300"
            } rounded-lg px-3 py-2 focus:outline-none`}
          />
          {errors.password && (
            <p className="text-red-500 text-sm mt-1">{errors.password}</p>
          )}
        </div>

        {/* Submit Button */}
        <button
          type="submit"
          className="w-full bg-blue-600 text-white py-2 rounded-lg hover:bg-blue-700 transition duration-200"
        >
          Submit
        </button>
      </form>
    </div>
  );
}
```

---

### **Step 2: Integrate into App.jsx**

```jsx
// src/App.jsx
import FormValidation from "./components/FormValidation";

export default function App() {
  return <FormValidation />;
}
```

---

## **6. Logic Breakdown**

| Step  | Description                                                                  |
| ----- | ---------------------------------------------------------------------------- |
| **1** | `useState` manages both the form data (`formData`) and errors (`errors`)     |
| **2** | `handleChange()` keeps input fields synced with state (controlled inputs)    |
| **3** | `validate()` checks all fields and returns any error messages                |
| **4** | `handleSubmit()` triggers validation and either shows errors or submits data |
| **5** | Conditional rendering displays red text if there’s an error                  |

---

## **7. Core React Concepts**

### **(a) Controlled Components**

Each `<input>` is connected to React state via:

```jsx
value={formData.name}
onChange={handleChange}
```

This ensures React always knows the current input value.

### **(b) Dynamic Class Names**

We use template literals to style invalid inputs red:

```jsx
className={`w-full border ${
  errors.name ? "border-red-500" : "border-gray-300"
}`}
```

### **(c) Conditional Rendering**

If there’s an error, display the error message:

```jsx
{errors.name && <p className="text-red-500">{errors.name}</p>}
```

---

## **8. Why This Approach Works**

| Challenge                 | React Solution                     |
| ------------------------- | ---------------------------------- |
| Need real-time validation | Controlled inputs + `useState`     |
| Need reactive UI feedback | Conditional rendering              |
| Avoid manual DOM updates  | React re-renders automatically     |
| Maintain clean structure  | Separation of logic + presentation |

---

## **9. Extensions & Ideas**

Once you understand the basics:

* Add password strength indicator
* Add confirm password
* Use `useEffect` for live validation (validate as user types)
* Integrate with APIs (like form submission to backend)
* Use libraries like **Formik** or **React Hook Form** later

---

## **10. Key Learnings**

* Controlled forms in React
* Validation using state and regex
* Conditional rendering for UX feedback
* Managing multiple pieces of related state
* Tailwind for quick UI consistency

---

## **11. Reflection**

You now know:

* How forms work in React
* Why we use controlled inputs
* How validation logic integrates cleanly with React state
* How re-rendering automatically updates the UI

This is **one of the most fundamental React patterns** — you’ll use it in every real-world app, from login to checkout.

---

# **Project 10 — E-Commerce Advance Filtering**


## **1. Project Overview**

We’ll build a **product listing page** with filtering functionality:

* Display a list of products (name, category, price)
* Filter products by category (e.g., Electronics, Clothing)
* Filter products by price range
* Search products by name
* Live updates on filter changes
* Clean responsive layout with TailwindCSS

**Purpose:** Simulates a real-world e-commerce filtering system.

---

## **2. Problem**

In e-commerce sites:

* Hardcoding filtered views is inefficient
* Users need dynamic filtering options
* React can **efficiently render filtered data** using state and mapping

Without React, filtering requires **manual DOM manipulation**, which becomes messy as products grow.

---

## **3. Concepts Used**

| Concept                   | Why We Use It                                            |
| ------------------------- | -------------------------------------------------------- |
| Components                | Separate ProductCard and FilterPanel for clean structure |
| Props                     | Pass product info to ProductCard                         |
| useState                  | Track products, filter criteria, search input            |
| useEffect                 | Optional: for side effects or filter automation          |
| Array Mapping & Filtering | Dynamically render filtered products                     |
| Conditional Rendering     | Show “No products found” message if filter empty         |
| TailwindCSS               | Quick, responsive UI styling                             |
| Event Handling            | Capture filter changes and search input                  |

---

## **4. Folder & File Setup**

```
src/
 ├── components/
 │    ├── ProductCard.jsx
 │    ├── ProductFilter.jsx
 │    ├── ProductList.jsx
 │
 ├── App.jsx
 ├── index.css
 ├── main.jsx
```

---

## **5. Step-by-Step Implementation**

### **Step 1: Create Product Data**

```jsx
// src/components/ProductList.jsx
import { useState } from "react";
import ProductCard from "./ProductCard";
import ProductFilter from "./ProductFilter";

const productsData = [
  { id: 1, name: "Laptop", category: "Electronics", price: 1200 },
  { id: 2, name: "T-Shirt", category: "Clothing", price: 25 },
  { id: 3, name: "Headphones", category: "Electronics", price: 200 },
  { id: 4, name: "Sneakers", category: "Footwear", price: 80 },
  { id: 5, name: "Jeans", category: "Clothing", price: 50 },
  { id: 6, name: "Smartphone", category: "Electronics", price: 900 },
];
```

---

### **Step 2: Set up State for Filters**

```jsx
export default function ProductList() {
  const [categoryFilter, setCategoryFilter] = useState("All");
  const [searchTerm, setSearchTerm] = useState("");
  const [priceFilter, setPriceFilter] = useState([0, 2000]); // min-max range

  // Filtering Logic
  const filteredProducts = productsData.filter((product) => {
    const matchesCategory =
      categoryFilter === "All" || product.category === categoryFilter;
    const matchesSearch = product.name
      .toLowerCase()
      .includes(searchTerm.toLowerCase());
    const matchesPrice =
      product.price >= priceFilter[0] && product.price <= priceFilter[1];

    return matchesCategory && matchesSearch && matchesPrice;
  });

  return (
    <div className="min-h-screen bg-gray-50 p-6">
      <h1 className="text-3xl font-bold mb-6 text-center">Products</h1>

      {/* Filter Panel */}
      <ProductFilter
        categoryFilter={categoryFilter}
        setCategoryFilter={setCategoryFilter}
        searchTerm={searchTerm}
        setSearchTerm={setSearchTerm}
        priceFilter={priceFilter}
        setPriceFilter={setPriceFilter}
      />

      {/* Products Grid */}
      <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-6 mt-6">
        {filteredProducts.length > 0 ? (
          filteredProducts.map((product) => (
            <ProductCard key={product.id} product={product} />
          ))
        ) : (
          <p className="col-span-full text-center text-gray-500">
            No products found.
          </p>
        )}
      </div>
    </div>
  );
}
```

---

### **Step 3: Create ProductCard Component**

```jsx
// src/components/ProductCard.jsx
export default function ProductCard({ product }) {
  return (
    <div className="bg-white shadow-md rounded-xl p-4">
      <h2 className="font-semibold text-lg">{product.name}</h2>
      <p className="text-gray-500">{product.category}</p>
      <p className="text-blue-600 font-bold">${product.price}</p>
    </div>
  );
}
```

---

### **Step 4: Create Filter Panel Component**

```jsx
// src/components/ProductFilter.jsx
export default function ProductFilter({
  categoryFilter,
  setCategoryFilter,
  searchTerm,
  setSearchTerm,
  priceFilter,
  setPriceFilter,
}) {
  const categories = ["All", "Electronics", "Clothing", "Footwear"];

  return (
    <div className="flex flex-col md:flex-row justify-between items-center gap-4 mb-6">
      {/* Search */}
      <input
        type="text"
        placeholder="Search products..."
        value={searchTerm}
        onChange={(e) => setSearchTerm(e.target.value)}
        className="border border-gray-300 rounded-lg px-3 py-2 focus:outline-none w-full md:w-1/3"
      />

      {/* Category Filter */}
      <select
        value={categoryFilter}
        onChange={(e) => setCategoryFilter(e.target.value)}
        className="border border-gray-300 rounded-lg px-3 py-2 focus:outline-none"
      >
        {categories.map((cat) => (
          <option key={cat} value={cat}>
            {cat}
          </option>
        ))}
      </select>

      {/* Price Filter */}
      <input
        type="range"
        min="0"
        max="2000"
        value={priceFilter[1]}
        onChange={(e) => setPriceFilter([0, Number(e.target.value)])}
        className="w-full md:w-1/3"
      />
      <span className="text-gray-600">${priceFilter[0]} - ${priceFilter[1]}</span>
    </div>
  );
}
```

---

### **Step 5: Integrate in App.jsx**

```jsx
// src/App.jsx
import ProductList from "./components/ProductList";

export default function App() {
  return <ProductList />;
}
```

---

## **6. Logic Breakdown**

1. **State Management**

   * `categoryFilter`, `searchTerm`, `priceFilter` track current filter selections.
2. **Filtering Logic**

   * `.filter()` checks each product against all active filters.
3. **Props Flow**

   * Parent `ProductList` manages state.
   * `ProductFilter` receives setter functions (`setCategoryFilter`, etc.) as props.
   * `ProductCard` receives `product` data to render.
4. **Conditional Rendering**

   * Show “No products found” if filter returns empty array.
5. **Dynamic Mapping**

   * `.map()` used for both products and category options.

---

## **7. Why This Approach Works**

| Challenge                | React Solution                                               |
| ------------------------ | ------------------------------------------------------------ |
| Multiple filter criteria | Use `useState` and combine with `.filter()`                  |
| Updating UI reactively   | State changes automatically re-render filtered list          |
| Clean separation         | `ProductFilter` handles input, `ProductCard` handles display |
| Scalable                 | Easily add more filters (color, brand) without breaking code |

---

## **8. Key Learnings**

* Combining **multiple states** for dynamic UI
* Controlled inputs in filtering
* Passing **setter functions as props**
* Real-world pattern: **Parent manages data + child handles UI**
* Tailwind for clean, responsive product grid

---

## **9. Reflection**

This is essentially how **real e-commerce sites** work for filtering products.
Once you understand this, you can:

* Add **sorting (price high→low, low→high)**
* Add **API fetching** instead of static products
* Extend to **cart functionality** using `useReducer` or context

---

At this point, you’ve built **10 full mini-projects**, covering:

* Components & props
* JSX rules & dynamic rendering
* State & hooks (`useState`, `useEffect`)
* Conditional rendering
* Forms & validation
* Advanced UI patterns (Accordion, Testimonials)
* Mini real-world app (E-commerce filtering)
* Tailwind for clean, maintainable UI

---